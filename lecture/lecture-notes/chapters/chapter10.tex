\chapter{Undecidability and Incompleteness}

In this final chapter, we explore how we can work with theories algorithmically. The highlight will be \emph{Gödel's Incompleteness Theorems} from 1931, which show the limits of the formal approach and which halted the decades-long program of formalizing mathematics. We do not have enough space to provide formal definitions and complete proofs here, so we will sometimes operate on a somewhat intuitive level. We will focus on understanding the meaning of the statements and the ideas of the proofs.

We will understand the concept of an \emph{algorithm} intuitively as well. If we wanted to formalize it, the most common (but by no means the only) choice would be the notion of a \emph{Turing machine}.\footnote{See the courses NTIN071 Automata and Grammars, NTIN090 Introduction to Complexity and Computability.}

\section{Recursive Axiomatization and Decidability}

In the proof systems we have discussed (the tableau method, resolution, Hilbert calculus), we allowed the theory $T$ in which we are proving to be infinite. However, we have not yet considered how it is given. If we want to verify that a given object (tableau, resolution tree, sequence of formulas) is a valid proof, we need some algorithmic access to all axioms of $T$.

One possibility would be to require an \emph{enumerator} for $T$, i.e., an algorithm that writes out the axioms of $T$ on the output, and each axiom is eventually written out.\footnote{A necessary condition is that $T$ is countable. It suffices to assume that the language is countable.} Then it would be easy to confirm that a given proof is correct. However, if we received a proof that used an incorrect axiom, one that is not in $T$, we would never know: we would wait infinitely long to see if the enumerator outputs it at some point. Therefore, we require a stronger property that allows recognizing incorrect proofs as well: a \emph{recursive axiomatization}.\footnote{The word \emph{recursive} here does not mean the commonly known recursion, but refers to the formalization of an algorithm using `recursive functions' by Gödel. Recursive functions here mean the same as computable by some Turing machine; the theory of computability is sometimes called \emph{recursion theory}.}

\begin{definition}[Recursive Axiomatization]
    A theory $T$ is \emph{recursively axiomatized} if there is an algorithm that, for every input formula $\varphi$, halts and answers whether $\varphi \in T$.
\end{definition}

\begin{remark}
    In fact, an enumerator for $T$ would suffice if it is guaranteed to output the axioms in lexicographic order. That would be equivalent to a recursive axiomatization. (Think about why.)
\end{remark}

We focus on the question whether we can `algorithmically decide truth' in a given theory $T$ (i.e., the validity of an input formula). If so, we say the theory is \emph{decidable}. This is quite a strong property, so we also define \emph{partial decidability}, which means that if the input formula is valid, the algorithm will tell us, but if it is not valid, we may never get an answer.

\begin{definition}[Decidability]
A theory $T$ is said to be
\begin{itemize}
    \item \emph{decidable} if there is an algorithm that, for every input formula $\varphi$, halts and answers whether $T \models \varphi$,
    \item \emph{partially decidable} if there is an algorithm that, for every input formula:
    \begin{itemize}
        \item if $T \models \varphi$, halts and answers ``yes'',
        \item if $T \not\models \varphi$, either does not halt or halts and answers ``no''.
    \end{itemize}
\end{itemize}
\end{definition}
As usual, we can assume that $\varphi$ in the above definition is a sentence. Let us prove a simple proposition:

\begin{proposition}
    Let $T$ be recursively axiomatized. Then:
    \begin{enumerate}[(i)]
        \item $T$ is partially decidable,
        \item if $T$ is also complete, then it is decidable.
    \end{enumerate}
\end{proposition}
\begin{proof}
An algorithm showing partial decidability is the construction of a systematic tableau from $T$ for the entry $\F \varphi$.\footnote{Here, an enumerator of the axioms of $T$ suffices, or we can systematically generate all sentences (e.g., in lexicographic order) and test whether they are axioms.} If $\varphi$ is valid in $T$, the construction will end in finitely many steps and we can easily verify that the tableau is contradictory; otherwise, it may not halt.

If $T$ is complete, we know that exactly one of the following holds: either $T \proves \varphi$ or $T \proves \neg \varphi$. We can therefore start constructing, in parallel, tableaux for $\F \varphi$ and for $\T \varphi$ (proof and refutation of $\varphi$ from $T$): one of the constructions will halt after finitely many steps.
\end{proof}


\subsection{Recursively Enumerable Completion}

The requirement of completeness is too strong; we now show that it suffices to eb able to effectively describe all complete simple extensions.\footnote{I.e., `all models up to elementary equivalence'.}

\begin{definition}[Recursively Enumerable Completion]
We say that a theory $T$ has \emph{recursively enumerable completion} if it has up to equivalence only countably many complete simple extensions and (some) set of up to equivalence all complete simple extensions of the theory $T$ is \emph{recursively enumerable}, i.e., there is an algorithm that, for a given pair of natural numbers $(i,j)$, outputs the $i$-th axiom of the $j$-th extension (in some fixed order\footnote{Here, we need the language to be countable.}), or answers that such an axiom does not exist.\footnote{If there are fewer than $j$ extensions or if the $j$-th extension has fewer than $i$ axioms.}
\end{definition}

\begin{proposition}\label{propositon:recursively-enumerable-completion}    
    If a theory $T$ is recursively axiomatized and has a recursively enumerable completion, then $T$ is decidable.
\end{proposition}
\begin{proof}
For a given sentence $\varphi$, either $T \proves \varphi$, or there is a counterexample $\A \not\models \varphi$, thus also a complete simple extension $T_i$ of the theory $T$ such that $T_i \not\proves \varphi$. From the completeness of $T_i$, it follows that $T_i \proves \neg \varphi$. Our algorithm will construct in parallel the tableau proof of~$\varphi$ from $T$ and (gradually) the tableau proofs of $\neg \varphi$ from all complete simple extensions $T_1, T_2, \dots$ of the theory $T$.\footnote{It does not matter that there are infinitely many of them; we can use so-called \emph{dovetailing}: Perform the 1st step of constructing the 1st tableau, then the 2nd step of the 1st tableau and the 1st step of the 2nd tableau, the 3rd step of the 1st tableau, the 2nd step of the 2nd tableau, the 1st step of the 3rd tableau, etc.} We know that at least one of the tableaux that we are constructing in parallel is contradictory, and we can assume it is finite (as long as we do not extend contradictory branches of the tableau), so the algorithm will finish constructing it after finitely many steps.
\end{proof}

\begin{exercise}
Show that the following theories have recursively enumerable completion:
\begin{itemize}
\item The theory of pure equality (the empty theory in the language $L = \langle \rangle$ with equality),
\item The theory of unary predicate (the empty theory in the language $L = \langle U \rangle$ with equality, where $U$ is a unary relation symbol),
\item The theory of dense linear order DeLO* (the complete simple extensions are described in Corollary \ref{corollary:complete-simple-extensions-of-delo}),
\end{itemize}
These are recursively axiomatized theories (as they are finite), so they are decidable.
\end{exercise}

\begin{example}
    Finally, let us mention without proof a few more examples of decidable theories:
    \begin{itemize}  
        \item The theory of Boolean algebras (Alfred Tarski 1940),
        \item The theory of algebraically closed fields (Tarski 1949),
        \item The theory of commutative groups (Wanda Szmielew 1955).
    \end{itemize}
    These theories are also not complete, but recursively axiomatized and have recursively enumerable completion.
\end{example}

 
\subsection{Recursive Axiomatizability}

In the previous chapter, specifically in Section \ref{section:axiomatizability}, we addressed the question of when a class of structures [or a theory] can be described using axioms [of a certain form]. Now, let us focus on the question of when this can be done \emph{algorithmically}.

\begin{definition}[Recursive Axiomatizability]
A class of $L$-structures $K \subseteq \M_L$ is \emph{recursively axiomatizable} if there is a recursively axiomatized $L$-theory $T$ such that $K = \M_L(T)$. A theory $T'$ is \emph{recursively axiomatizable} if the class of its models is recursively axiomatizable, i.e., if $T'$ is equivalent to some recursively axiomatized theory.
\end{definition}
\begin{remark}
    Similarly, we could define \emph{recursively enumerable axiomatizability}.
\end{remark}

Let us prove the following simple proposition:

\begin{proposition}
    If $\A$ is a finite structure in a finite language with equality, then the theory $\Th(\A)$ is recursively axiomatizable.
\end{proposition}
\begin{remark}
    It follows that $\Th(\A)$ is decidable, which is not surprising: the validity of a sentence $\varphi$ in a finite structure $\A$ can be easily verified.
\end{remark}
\begin{proof}
    Let us enumerate the elements of the domain as $A = \{a_1, \dots, a_n\}$. The theory $\Th(\A)$ can be axiomatized by a single sentence of the form ``there exist exactly $n$ elements $a_1, \dots, a_n$ satisfying precisely those \emph{`basic relationships'} on function values and relation tuples that hold in the structure $\A$''.\footnote{For example, if $f^\A(a_4, a_2) = a_{17}$, we add the atomic formula $f(x_{a_4}, x_{a_2}) = x_{a_{17}}$ to the conjunction (where $x_{a_i}$ are variables corresponding to the individual elements). And if $(a_3, a_3, a_1) \notin R^\A$, we add $\neg R(x_{a_3}, x_{a_3}, x_{a_1})$.}    
\end{proof}
 
Let us give some standard examples of structures that can be `described algorithmically':

\begin{example}\label{example:structures-recursively-axiomatizable}
For the following structures, $\Th(\A)$ is recursively axiomatizable, and thus decidable:

\begin{itemize}
    \item $\langle \mathbb{Z}, \leq \rangle$, this is the so-called theory of \emph{discrete linear orders},        
    \item $\langle \mathbb{Q}, \leq \rangle$, this is the theory DeLO,
    \item $\langle \mathbb{N}, S, 0 \rangle$, the theory of \emph{successor with zero},
    \item $\langle \mathbb{N}, S, +, 0 \rangle$, \emph{Presburger arithmetic},
    \item $\langle \mathbb{R}, +, -, \cdot, 0, 1 \rangle$, the theory of \emph{real closed fields},\footnote{This significant result by A. Tarski (1949) also means that it is possible to algorithmically decide which properties hold in Euclidean geometry.}
    \item $\langle \mathbb{C}, +, -, \cdot, 0, 1 \rangle$, the theory of \emph{algebraically closed fields of characteristic 0}.
\end{itemize}
\end{example}
   
\begin{corollary}
    For the structures listed in Example \ref{example:structures-recursively-axiomatizable}, it holds that $\Th(\A)$ is decidable.
\end{corollary}


\begin{remark}\label{remark:std-arithmetic-not-recursively-axiomatizable}
    As follows from Gödel's First Incompleteness Theorem (see below), the \emph{standard model of arithmetic}, i.e., the structure $\underline{\mathbb{N}} = \langle \mathbb{N}, S, +, \cdot, 0, \leq \rangle$, does \emph{not} have recursively axiomatizable theory.
\end{remark}


\section{Arithmetic}

The properties of natural numbers play an important role not only in mathematics but also, for example, in cryptography. Recall that the language of arithmetic is the language $L = \langle S, +, \cdot, 0, \leq \rangle$ with equality. As mentioned in Remark \ref{remark:std-arithmetic-not-recursively-axiomatizable}, the so-called \emph{standard model of arithmetic} $\underline{\mathbb{N}} = \langle \mathbb{N}, S, +, \cdot, 0, \leq \rangle$ does not have a recursively axiomatizable theory. Therefore, we use recursively axiomatized theories that attempt to describe the properties of $\underline{\mathbb{N}}$ partially; these theories are called \emph{arithmetics}.

\subsection{Robinson and Peano Arithmetic}

We will mention only the two most important examples of arithmetics: \emph{Robinson arithmetic} and \emph{Peano arithmetic}.

\begin{definition}[Robinson Arithmetic]
\emph{Robinson arithmetic} is the theory $Q$ in the language of arithmetic consisting of the following (finite) set of axioms:
\begin{align*}
    &\neg S(x) = 0& &x \cdot 0 = 0\\
    &S(x) = S(y) \rightarrow x = y& &x \cdot S(y) = x \cdot y + x\\
    &x + 0 = x& &\neg x = 0 \rightarrow (\exists y)(x = S(y))\\
    &x + S(y) = S(x + y)& &x \le y \leftrightarrow (\exists z)(z + x = y)\qquad
\end{align*}
\end{definition}

Robinson arithmetic is very weak; it cannot prove, for example, the commutativity or associativity of addition or multiplication, or the transitivity of order.

On the other hand, it can prove all \emph{existential statements about numerals} that are valid in $\underline{\mathbb{N}}$. By this, we mean formulas that, in prenex form, have only existential quantifiers, and into which we have substituted \emph{numerals} $\underline{n} = S(\dots S(0) \dots)$ for the free variables.

\begin{example}
For instance, for the formula $\varphi(x,y)$ of the form $(\exists z)(x + z = y)$, we have that $Q \proves \varphi(\underline{1}, \underline{2})$, where $\underline{1} = S(0)$ and $\underline{2} = S(S(0))$.    
\end{example}

Thus, the following proposition holds; we will omit the proof.

\begin{proposition}\label{proposition:robinson-satisfies-existence-about-numerals}
    If $\varphi(x_1, \dots, x_n)$ is an existential formula and $a_1, \dots, a_n \in \mathbb{N}$, then:
    $$
    Q \proves \varphi(x_1 / \underline{a_1}, \dots, x_n / \underline{a_n}) \text{ if and only if } \underline{\mathbb{N}} \models \varphi[e(x_1 / a_1, \dots, x_n / a_n)]
    $$
\end{proposition}

A useful extension of Robinson arithmetic is the so-called Peano arithmetic, which allows for \emph{proof by induction}:

\begin{definition}[Peano Arithmetic]
\emph{Peano arithmetic} $\text{\it PA}$ is an extension of Robinson arithmetic $Q$ with the \emph{axiom schema of induction}, i.e., for each $L$-formula $\varphi(x, \overline{y})$, the following axiom is added:
$$
(\varphi(0, \overline{y}) \land (\forall x)(\varphi(x, \overline{y}) \limplies \varphi(S(x), \overline{y}))) \limplies (\forall x)\varphi(x, \overline{y})
$$
\end{definition}

Peano arithmetic is a much better approximation of the theory $\Th(\underline{\mathbb{N}})$; it can prove all `basic' properties valid in $\underline{\mathbb{N}}$ (such as the commutativity and associativity of addition). However, there are still sentences in the language of arithmetic that are valid in $\underline{\mathbb{N}}$ but independent in Peano arithmetic.\footnote{As we will show in Gödel's First Incompleteness Theorem.} 


\begin{remark}
    If we moved up to \emph{second-order} logic, we could axiomatize the structure $\underline{\mathbb N}$ (up to isomorphism) by extending Peano arithmetic with the following second-order formula, the so-called \emph{axiom of induction}:
    $$
    (\forall X)((X(0) \land (\forall x)(X(x) \limplies X(S(x)))) \limplies (\forall x)X(x))
    $$
    Recall that $X$ represents (any) unary relation, i.e., subset of the universe. By applying the axiom of induction to the set of all successors of 0, we obtain that every element (of the given model) is a successor of zero. Thus, we can construct an isomorphism with $\underline{\mathbb N}$.
    \end{remark}
    
    \section{Undecidability of Predicate Logic}
    
    In this section, we will show that it is not possible to (algorithmically) decide the logical validity of first-order formulas. (In other words, the empty theory over a given language is undecidable.)
    
    \begin{theorem}[On undecidability of predicate logic]\label{theorem:undecidability-of-predicate-logic}
    There is no algorithm that, given an input formula $\varphi$, decides whether it is logically valid.\footnote{That is, whether the formula $\varphi$ is a tautology, i.e.,  whether $\models\varphi$. Here we are talking about first-order formulas, in any language.}
    \end{theorem}
    
    Since we do not yet have the necessary formalism regarding algorithms, such as the notion of a Turing machine, we will choose another \emph{undecidable problem} as a starting point. The most well-known is the so-called \emph{Halting problem}, i.e., the question of whether a given program halts on a given input.\footnote{You will prove its undecidability in the courses NTIN071 Automata and Grammars and again in NTIN090 Foundations of Complexity and Computability.} We will make our task simpler by choosing another undecidable problem, the so-called \emph{Hilbert's Tenth Problem}.\footnote{Hilbert posed it in 1900 and published in 1902 along with 22 other problems; his problems significantly influenced 20th and 21st-century mathematics. Some remain unsolved, such as the Riemann hypothesis, \href{https://en.wikipedia.org/wiki/Riemann_hypothesis}{see Wikipedia}.}
    
    \subsection{Hilbert's Tenth Problem}
    
    Let us have a polynomial $p(x_1,\dots,x_n)$ with integer coefficients. Hilbert's Tenth Problem asks for an algorithm that decides whether such an input polynomial has an integer root, or in other words whether the \emph{Diophantine equation} $p(x_1,\dots,x_n)=0$ has an (integer) solution:
    \begin{quote}
        ``Find an algorithm that, after finitely many steps, determines whether a given Diophantine equation with any number of variables and integer coefficients has an integer solution.''
    \end{quote}
    
    If Hilbert had lived to see the resolution of his tenth problem in 1970, he would have been surprised that no such algorithm exists.
    
    \begin{theorem}[Matiyasevich, Davis, Putnam, Robinson]
    The problem of existence of an integer solution to a given Diophantine equation with integer coefficients is (algorithmically) undecidable.
    \end{theorem}
    
    We will not provide the proof here, for lack of space. Actually, to prove undecidability, we will use the following corollary, which talks about polynomials with natural coefficients and solutions in natural numbers.
    
    \begin{corollary}
    There is no algorithm that, given a pair of polynomials $p(x_1,\dots,x_n)$ and $q(x_1,\dots,x_n)$ with \emph{natural} coefficients, decides whether they have a natural solution, i.e., whether it holds that
    $$
    \underline{\mathbb N}\models(\exists x_1)\dots(\exists x_n)\ p(x_1,\dots,x_n)=q(x_1,\dots,x_n)
    $$
    \end{corollary}
    \begin{proof}[Proof of the corollary]
    The proof is straightforward, utilizing the fact that every integer can be expressed as the difference of a pair of natural numbers, and conversely, every natural number can be expressed as the sum of four squares (of integers).\footnote{The so-called Lagrange's Four-Square Theorem.} Thus, any Diophantine equation can be transformed into an equation from the corollary, and vice versa.
    \end{proof}
    
    \subsection{Proof of Undecidability}
    
    Recall that the Robinson arithmetic $Q$ has only finitely many axioms, $\underline{\mathbb N}$ is its model, and it can prove all \emph{existential statements about numerals} valid in $\underline{\mathbb N}$. We are now ready to prove the theorem on undecidability of predicate logic.
    
    \begin{proof}[Proof of the theorem on undecidability of predicate logic]
    Consider a formula $\varphi$ of the form 
    $$(\exists x_1)\dots(\exists x_n)\ p(x_1,\dots,x_n)=q(x_1,\dots,x_n)
    $$ 
    where $p$ and $q$ are polynomials with natural coefficients. According to Proposition \ref{proposition:robinson-satisfies-existence-about-numerals}, we have:
    $$
    \underline{\mathbb N}\models \varphi\text{ if and only if }Q\proves \varphi
    $$
    
    Let $\psi_Q$ denote the conjunction (of the general closures) of all axioms of $Q$. Clearly, $Q\proves\varphi$ if and only if $\psi_Q\proves\varphi$, which holds if and only if $\proves\psi_Q\limplies\varphi$. According to the Soundness and Completeness Theorems, this is equivalent to $\models\psi_Q\limplies\varphi$. We thus obtain the following equivalence:
    $$
    \underline{\mathbb N}\models \varphi\text{ if and only if }\models \psi_Q\limplies\varphi
    $$
    This means that if there were an algorithm deciding logical validity, we could decide the existence of a natural solution to the equation $p(x_1,\dots,x_n)=q(x_1,\dots,x_n)$, i.e., Hilbert's Tenth Problem would be decidable.\footnote{We show that there is a \emph{reduction} of the `hard' problem (Hilbert's Tenth) to our problem, thus our problem is also `hard'.} This would be a contradiction.
    \end{proof}
    
    \section{Gödel's Theorems}
    
    Finally, we will present the famous Gödel's incompleteness theorems, the understanding of which should unquestionably be a part of every computer scientist's education. We will try to explain the main ideas of the proofs, but we will omit all technical details.
    
    \subsection{The First Incompleteness Theorem}
    
    First, we state Gödel's \emph{First Incompleteness Theorem}, and explain the meaning of its assumptions.
    
    \begin{theorem}[The First Incompleteness Theorem]
    For every consistent recursively axiomatized extension $T$ of Robinson arithmetic, there exists a sentence that is valid in $\underline{\mathbb N}$ but not provable in $T$.    
    \end{theorem}
    
    Such a sentence is called a \emph{Gödel sentence}. Very informally speaking, Gödel's First Incompleteness Theorem states that the properties of the arithmetic of natural numbers cannot be `reasonably', effectively described (in first-order logic). Every such description is necessarily `incomplete'. It is important to realize that we are talking about \emph{validity} in the standard model of arithmetic, i.e., in the structure $\underline{\mathbb N}$, while \emph{provability} is in the theory $T$. (According to the Completeness Theorem, every sentence \emph{valid in $T$} is also provable in $T$.)
    
    Consistency is a necessary assumption because in an inconsistent theory every sentence is provable. Recall that recursive axiomatizability can be understood as `effective specification' of axioms (using an algorithm), without this property such a theory would not be useful. The requirement that the theory be an extension of Robinson arithmetic should be understood as the assumption that it has at least `basic arithmetic strength', that it can `talk' about natural numbers in a certain way. There are various versions of this assumption, with theories other than Robinson arithmetic, and it is not necessary, for example, that it be a direct extension, it is enough if Robinson arithmetic is `definable' in the theory in a certain sense. But a theory in which `natural numbers cannot be encoded' (and here it is important that we can talk not only about addition but also about multiplication) is `too weak'.
    
    It is helpful to realize that, in particular, the following statement about `incompleteness' also holds:
    
    \begin{corollary}
        If a theory $T$ satisfies the assumptions of the First Incompleteness Theorem and moreover $\underline{\mathbb N}$ is a model of the theory $T$, then $T$ is not complete.
    \end{corollary}
    \begin{proof}
        Assume for contradiction that $T$ is complete. Consider the sentence $\varphi$, which is true in $\underline{\mathbb N}$ but not provable in $T$. By completeness, we know that $T\proves\neg\varphi$, but then the Soundness Theorem says that $T\models\neg\varphi$, thus $\varphi$ is false in $\underline{\mathbb N}$, which is a contradiction.
    \end{proof}
    
    Not only is the statement of the First Incompleteness Theorem interesting, but also its proof: Gödel came up with a completely new, revolutionary proof technique for its time. The sentence constructed in the proof formalizes the statement \emph{``I am not provable in $T$''}, and the proof is based on the following two principles, which we will describe somewhat informally below:
    \begin{itemize}
        \item \emph{arithmetization of syntax}, i.e., encoding sentences and their provability into natural numbers,
        \item \emph{self-reference}, i.e., the ability of a sentence to `talk about itself' (about its code).
    \end{itemize}
    
    \subsubsection*{Arithmetization of Provability}
    
    Finite syntactic objects, such as terms, formulas, finite tableaux, and thus also tableau proofs, can be `reasonably' encoded into natural numbers.\footnote{Imagine any reasonable way to write the given object into a file. The file in binary code is a sequence of 0s and 1s. Prefix it with a one so as not to start with zero, and you have a binary representation of a natural number.} The specific way this can be done, the so-called \emph{Gödel numbering}, we will skip as a technical detail. It is enough for us that we can `algorithmically' encode and decode objects (and `simulate manipulation with objects' on their codes).
    
    Denote the code of a formula $\varphi$ as $\lceil\varphi\rceil$, similarly for other syntactic objects. We will denote the numeral corresponding to the code of $\varphi$, i.e., the $\lceil\varphi\rceil$-th numeral, as $\underline{\varphi}$. For a given theory $T$, we define the following binary relation on the set of all natural numbers:
    \begin{align*}
        (n,m)\in\Proof_T\ \text{ if and only if \ \ $n=\lceil\varphi\rceil$ and $m=\lceil\tau\rceil$, where $\tau$ is a tableau proof} \\ \text{of the sentence $\varphi$ from $T$}    
    \end{align*}
   
    If we have effective access to the axioms, we can also effectively check whether $\tau$ is really a proof of $\varphi$ (where $\tau$ and $\varphi$ we obtain by decoding $m$ and $n$), so the following holds:
    \begin{observation}
    If $T$ is recursively axiomatized, the relation $\Proof_T\subseteq\mathbb N^2$ is \emph{recursive}.
    \end{observation}
    Here \emph{recursive} means that there exists an algorithm that always halts and corretly answers, for given $n,m\in\mathbb N$, whether $(n,m)\in\Proof_T$.
    
    A crucial but very technical part of the proof of the First Incompleteness Theorem is the following proposition, which we will leave without proof.
    
    \begin{proposition}
    If $T$ is additionally an extension of Robinson arithmetic $Q$, then there exists a formula $\Prf_T(x,y)$ in the language of arithmetic that \emph{represents} the relation $\Proof_T$, i.e., for all $n,m\in\mathbb N$ it holds:
    \begin{itemize}
        \item If $(n,m)\in\Proof_T$, then $Q\proves\Prf_T(\underline{n},\underline{m})$,
        \item otherwise $Q\proves\neg\Prf_T(\underline{n},\underline{m})$.
    \end{itemize} 
    \end{proposition}
    
    The formula $\Prf_T(x,y)$ thus expresses \emph{``$y$ is a proof of $x$ in $T$''}.\footnote{More precisely, the tableau whose code is $y$ is a proof of the sentence whose code is $x$.} Then we can express that \emph{``$x$ is provable in $T$''} by the formula $(\exists y)\Prf_T(x,y)$. Note that the following observation holds, as the witness provides the code of some tableau proof, and $\underline{\mathbb N}$ satisfies the axioms of~$Q$:
    \begin{observation}\label{observation:proof-predicate}
    $T\proves\varphi$ if and only if $\underline{\mathbb N}\models (\exists y)\Prf_T(\underline{\varphi},y)$.  
    \end{observation}
    We will also need the following corollary, which we will state without proof:
    \begin{corollary}[On the provability predicate]\label{corollary:predicate-of-provability}
        If $T\proves\varphi$, then $T\proves (\exists y)\Prf_T(\underline{\varphi},y)$.
    \end{corollary}
    
    We can thus express that a given sentence is, or is not, provable. But how can a sentence say `about itself' that it is not provable? For this, we use the \emph{principle of self-reference}.
    
    \subsubsection*{Self-reference}
    
    To illustrate the principle of self-reference, for clarity, let us imagine a sentence in English instead of a logical sentence, and instead of the property of ``being provable'' a statement about the number of characters. Consider the following sentence:
    \begin{quote}
        \texttt{This sentence has 32 characters.}
    \end{quote}
    In natural language, we easily express self-reference with the pronoun ``This'', from the context we know that it refers to the sentence itself. In formal systems, however, we typically do not have self-reference directly available. We usually have \emph{direct reference} available, as in the following example:
    \begin{quote}
        \texttt{The following sentence has 41 characters. ``The following sentence has 41 characters.''}
    \end{quote}
    Here, however, there is no self-reference. We help ourselves with a trick we will call `doubling':
    \begin{quote}
        \texttt{The following sentence, written once and again in quotes, has 156\\ characters. ``The following sentence, written once and again in quotes\\ has 156 characters.''}
    \end{quote}
    Using direct reference and doubling, we can obtain self-reference.
    \begin{remark}
        The same principle can be used to construct a program in C whose output is its own code (34 is the ASCII code for double quotes):    
    {\small
    \begin{verbatim}
    main(){char *c="main(){char *c=%c%s%c; printf(c,34,c,34);}"; printf(c,34,c,34);}    
    \end{verbatim}
    }
    \end{remark}
    
    \subsection{Proof and Consequences}
    
    In this subsection, we will prove Gödel's First Incompleteness Theorem and discuss its consequences. We will need the following theorem, which describes how we technically use the principle of self-reference. It can be viewed as a form of `diagonalization argument',\footnote{Diagonalization refers to an argument reminiscent of \emph{Cantor's diagonal argument}, known from the proof of the uncountability of $\mathbb R$. A similar argument, using self-reference, can be found, for example, in the \emph{Barber paradox}, or in the proof of the undecidability of the \emph{Halting problem}.} hence this theorem is sometimes also called the \emph{diagonal lemma}.
    
    \begin{theorem}[Fixed-point theorem]
    If $T$ is an extension of Robinson arithmetic, then for every formula $\varphi(x)$ (in the language of the theory $T$) there exists a sentence $\psi$ such that:
    $$
    T\proves \psi \liff \varphi(\underline{\psi})
    $$
    \end{theorem}
    The sentence $\psi$ is thus \emph{self-referential}, it says about itself: ``I have the property $\varphi$''.\footnote{More precisely, it says this about the numeral corresponding to its code.} We will explain only the idea of the proof. Note how direct reference and doubling are used in the proof.
    \begin{proof} Consider a \emph{doubling function}, a function $d\colon\mathbb N\to\mathbb N$ such that for every formula $\chi(x)$ we have that:
    $$
    d(\lceil \chi(x)\rceil)=\lceil\chi(\underline{\chi(x)})\rceil
    $$
    The function $d$ thus takes as input a natural number $n$, which it decodes as a formula in one variable, substitutes the corresponding numeral $\underline{n}$ into this formula,\footnote{Here \emph{numeral} corresponds to `quotes' from the previous informal description of self-reference, and $d(\lceil\chi\rceil)$ means ``$\chi$ written once and again in quotes.''} and re-encodes the resulting sentence.
    
    Using the assumption that $T$ is an extension of $Q$, it can be shown that this function is \emph{representable} in $T$. For simplicity, assume it is representable by a term,\footnote{Though in reality, it is represented by a (complex) formula.} and denote the term also as $d$. This means that for every formula $\chi(x)$ we have:
    $$
    T\proves d(\underline{\chi(x)})=\underline{\chi(\underline{\chi(x)})}
    $$
    Thus Robinson arithmetic, and therefore our theory $T$, proves \emph{about numerals}, that $d$ really `doubles'.
    
    The desired self-referential sentence $\psi$ is the following sentence:\footnote{The following sentence, written once and again in quotes, has the property $\varphi$. ``The following sentence, written once and again in quotes has the property $\varphi$.''}
    $$
    \varphi(d(\underline{\varphi(d(x))}))
    $$
    We want to prove that $T\proves \psi \liff \varphi(\underline{\psi})$, i.e., $T \proves \varphi(d(\underline{\varphi(d(x))}))\liff\varphi(\underline{\varphi(d(\underline{\varphi(d(x))}))})$. To do this, we need to verify that:
    $$
    T \proves d(\underline{\varphi(d(x))})=\underline{\varphi(d(\underline{\varphi(d(x))}))}
    $$
    But this we know from the representability of $d$, where we substitute the formula $\varphi(d(x))$ for $\chi(x)$.
    \end{proof}
    
    Before proceeding to the proof of Gödel's theorem, we will show as a warm-up one consequence of the Fixed-point Theorem: By a \emph{definition of truth} in an arithmetic theory $T$, we mean a formula $\tau(x)$ such that for every sentence $\psi$ it holds that: 
    $$
    T\proves\psi\liff\tau(\underline{\psi})
    $$
    If a definition of truth existed, it would mean that instead of proving a sentence, it would suffice to calculate its code, substitute the corresponding numeral into $\tau$, and evaluate.
    
    \begin{theorem}[Undefinability of truth]
        In no consistent extension of Robinson arithmetic does a definition of truth exist.
    \end{theorem}
    The proof uses the \emph{Liar paradox}, expressing the sentence ``I am not true in $T$''.
    \begin{proof}
    Assume for contradiction that there exists a definition of truth $\tau(x)$.
    We use the Fixed-point Theorem, where we take $\neg\tau(x)$ as the formula $\varphi(x)$. We get the existence of a sentence $\psi$ such that:
    $$
    T\proves\psi\liff\neg\tau(\underline{\psi})
    $$
    Since $\tau(x)$ is a definition of truth, it also holds that $T\proves\psi\liff\tau(\underline{\psi})$, hence $T\proves\tau(\underline{\psi})\liff\neg\tau(\underline{\psi})$. This would mean that $T$ is inconsistent.
    \end{proof}
    
    The proof of Gödel's theorem uses the same trick, but for the sentence ``I am not provable in $T$''.
    
    \begin{proof}[Proof of the First Incompleteness Theorem]
    Let $T$ be a consistent recursively axiomatized extension of Robinson arithmetic. We want to find a Gödel sentence $\psi_T$ that is valid in $\underline{\mathbb N}$ but not provable in $T$.
    
    Such a sentence is obtained from the Fixed-point Theorem as a sentence expressing ``I am not provable in $T$''. Let $\varphi(x)$ be the formula $\neg(\exists y)\Prf_T(x,y)$ (``$x$ is not provable in $T$''). According to the Fixed-point Theorem, there exists a sentence $\psi_T$ satisfying:
    $$
    T\proves\psi_T\liff\neg(\exists y)\Prf_T(\underline{\psi_T},y)
    $$
    The sentence $\psi_T$ is thus in $T$ equivalent to the sentence that expresses that $\psi_T$ is not provable in $T$. It can be shown that the same equivalence holds in $\underline{\mathbb N}$ (as that is how we constructed $\Prf_T$ and $\psi_T$):
    $$
    \underline{\mathbb N}\models\psi_T\ \text{ if and only if }\ \underline{\mathbb N}\models\neg(\exists y)\Prf_T(\underline{\psi_T},y)
    $$
    From Observation \ref{observation:proof-predicate}, we get that 
    $$
    \underline{\mathbb N}\models\psi_T\ \text{ if and only if }\ T\not\proves\psi_T
    $$
    that is, $\psi_T$ is valid in $\underline{\mathbb N}$ if and only if it is not provable in $T$. It is sufficient to show that $\psi_T$ is not provable in $T$. Assume for contradiction that $T\proves\psi_T$. From self-reference, we know that 
    $T\proves\neg(\exists y)\Prf_T(\underline{\psi_T},y)$.
    From Corollary \ref{corollary:predicate-of-provability} on the provability predicate, we get that $T\proves (\exists y)\Prf_T(\underline{\psi_T},y)$, which would mean that $T$ is inconsistent.
    \end{proof}
    
    Finally, we will show two consequences and one strengthening. The following immediate consequence we mentioned earlier:
    
    \begin{corollary}
    If $T$ is a recursively axiomatized extension of Robinson arithmetic and $\underline{\mathbb N}$ is a model of $T$, then $T$ is not complete.
    \end{corollary}
    \begin{proof}
    Since $T$ has a model, it is consistent. It thus satisfies the assumptions of the First Incompleteness Theorem, so the Gödel sentence $\psi_T$ is not provable in it. If it were complete, it would have to prove $\neg\psi_T$. But that would mean that $\underline{\mathbb N}\models\neg\psi_T$, while we know that $\psi_T$ is valid in $\underline{\mathbb N}$.  
    \end{proof}
    
    From this, it follows that the standard model of natural numbers cannot be recursively axiomatized:
    \begin{corollary}
    The theory $\Th(\underline{\mathbb N})$ is not recursively axiomatizable.    
    \end{corollary}
    \begin{proof}
    The theory $\Th(\underline{\mathbb N})$ is an extension of Robinson arithmetic and is valid in the model~$\underline{\mathbb N}$. If it were recursively axiomatizable, its recursive axiomatization (any one of them) could not be complete, according to the previous corollary. But $\Th(\underline{\mathbb N})$ is complete.
    \end{proof}
    
    One of the strengthenings of Gödel's First Theorem is the following statement, which we will state without proof. It shows that the assumption $\underline{\mathbb N}\models T$ in the first corollary above is, in fact, redundant.
    
    \begin{theorem}[Rosser's Trick, 1936]
    In every consistent recursively axiomatized extension of Robinson arithmetic, there exists an independent sentence. Thus, such a theory is not complete.    
    \end{theorem}
    
    \subsection{The Second Incompleteness Theorem}
    
    Gödel's Second Incompleteness Theorem states, informally speaking, that an effectively given, sufficiently rich theory cannot prove its own consistency. Consistency is expressed by the following sentence, which we denote as $\Con_T$:
    $$
    \neg(\exists y)\Prf_T(\underline{0=S(0)},y)
    $$
    Note that $\underline{\mathbb N}\models\Con_T$ holds, if and only if $T\not\proves 0=S(0)$. In other words, the sentence $\Con_T$ indeed expresses \emph{``The theory $T$ is consistent''.}
    
    \begin{theorem}[The Second Incompleteness Theorem]
    For any consistent recursively axiomatized extension $T$ of Peano arithmetic, the sentence $\Con_T$ is not provable in $T$.    
    \end{theorem}
    
    Note that the sentence $\Con_T$ is valid in $\underline{\mathbb N}$ (as $T$ is indeed consistent). It is also worth noting that the full Peano arithmetic is not required, a weaker assumption is sufficient. Now we will show the main idea of the proof of the Second Theorem:
    
    \begin{proof}[Proof of the Second Incompleteness Theorem]
    Consider the Gödel sentence $\psi_T$ expressing ``I am not provable in $T$''. In the proof of the First Incompleteness Theorem (specifically, in the first part), we showed that:
    \begin{quote}
        ``If $T$ is consistent, then $\psi_T$ is not provable in $T$.''
    \end{quote}
    From this, it follows that $T\not\proves\psi_T$, as $T$ is consistent. On the other hand, it can be formulated as ``$\Con_T\to \psi_T$ holds'' and if $T$ is an extension of Peano arithmetic, this statement can be formalized within the theory $T$, so it can be shown that:
    $$
    T\proves\Con_T\to\psi_T
    $$
    If we had that $T\proves\Con_T$, we would also get $T\proves\psi_T$, which would be a contradiction.
    \end{proof}
    
    Finally, we will show three consequences of the Second Theorem.
    
    \begin{corollary}
        There exists a model of {\it PA}, in which the sentence $(\exists y)\Prf_{\text{\it PA}}(\underline{0=S(0)},y)$ holds.
    \end{corollary}
    \begin{proof}
        The sentence $\Con_{\text{\it PA}}$ is not provable, hence also not valid in $\text{\it PA}$. But it is valid in $\underline{\mathbb N}$ (as $\text{\it PA}$ is consistent), which means that $\Con_{\text{\it PA}}$ is independent in $\text{\it PA}$. Therefore, its negation must hold in some model; this negation is equivalent to $(\exists y)\Prf_{\text{\it PA}}(\underline{0=S(0)},y)$.
            
    \end{proof}
    Note that this must be a non-standard model of $\text{\it PA}$, with the witness being a \emph{non-standard} element (i.e., one that is not the value of any numeral).
    
    \begin{corollary}
        There exists a consistent recursively axiomatized extension $T$ of Peano arithmetic, which `proves its inconsistency', i.e., such that $T\proves \neg \Con_T$.
    \end{corollary}
    \begin{proof}
    Consider the theory $T=\text{\it PA} \cup \{\neg \Con_{\text{\it PA}}\}$. This theory is consistent, as $\text{\it PA}\not\proves\Con_{\text{\it PA}}$. It trivially holds that $T\proves\neg\Con_{\text{\it PA}}$ (i.e., $T$ `proves the inconsistency' of the theory $\text{\it PA}$). Since $\text{\it PA}\subseteq T$, it also holds that $T\proves\neg\Con_T$.
    \end{proof}
    Note that $\underline{\mathbb{N}}$ cannot be a model of the theory $T$.
    
    Finally, let us look at the theory ZFC, i.e., Zermelo-Fraenkel set theory with the axiom of choice, which forms the foundation of formalized mathematics. This theory is not, strictly speaking, an extension of $\text{\it PA}$, but Peano arithmetic can be `interpreted' in it (in a certain sense). This means that even this theory cannot prove its own consistency.
    
    \begin{corollary}
        If the set theory ZFC is consistent, then the sentence $\Con_{ZFC}$ cannot be provable in ZFC.
    \end{corollary}
    
    Thus, if someone were to prove within the theory ZFC that ZFC is consistent, it would mean that ZFC is inconsistent. This serves as a fitting conclusion to our lecture.
