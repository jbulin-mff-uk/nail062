\chapter{Problém splnitelnosti}

\emph{Problém splnitelnosti výrokových formulí}, známý také jako \emph{problém SAT}\footnote{Z anglického `Boolean satisfiability problem'.} je následující výpočetní problém: Vstupem je výrok $\varphi$ v CNF (v nějakém rozumném kódování\footnote{Např. DIMACS-CNF formát, viz \href{https://en.wikipedia.org/wiki/SAT_solver}{Wikipedia}.}), a úkolem je rozhodnout, zda je $\varphi$ \emph{splnitelný}.

Jak jsme si ukázali v předchozí kapitole, můžeme každý výrok, nebo i každou výrokovou teorii v konečném jazyce, převést do CNF. Problém SAT je tedy v jistém smyslu univerzální; odpovídá na otázku, zda existuje model.

Známá Cook-Levinova věta říká, že problém SAT je \emph{NP-úplný}, tedy je v třídě NP (pokud nám orákulum prozradí správné ohodnocení proměnných, můžeme snadno ověřit, že všechny klauzule jsou splněny) a každý problém z třídy NP na něj lze převést v polynomiálním čase (konkrétně, výpočet Turingova stroje lze popsat pomocí CNF formule).\footnote{Viz předmět \href{https://is.cuni.cz/studium/predmety/index.php?do=predmet&kod=NTIN090}{NTIN090 Základy složitosti a vyčíslitelnosti}.}

Praktické SAT solvery si ale umí poradit s instancemi obsahujícími mnoho, dokonce až miliony, výrokových proměnných a klauzulí. V této kapitole si nejprve ukážeme praktickou aplikaci SAT solveru na problém `ze života', potom dva fragmenty problému SAT, tzv. \emph{2-SAT} a \emph{Horn-SAT}, pro které existují polynomiální algoritmy, a na závěr si ukážeme také algoritmus DPLL, který je základem (téměř?) všech SAT solverů. (V pozdější kapitole uvidíme také souvislost s \emph{rezoluční metodou}.)


\section{(draft) SAT solvery}\todo

Praktická ukázka použití řešiče SAT na konkrétní problém.

% from slides:

\begin{itemize}
    \item Problém {SAT}: Je daná výroková formule splnitelná?
    
    \item {Příklad}\ \ \mygreen{{\it Lze šachovnici bez dvou protilehlých rohů} perfektně}
    \mygreen{{\it pokrýt kostkami domina?}}
    Snadno vytvoříme výrokovou formuli, která je \myblue{splnitelná}, právě když
    to lze. Pak ji můžeme zkusit ověřit pomocí nějakého SAT řešiče.

    \item Nejlepší řešiče pro SAT: \href{http://www.satcompetition.org}{\myblue{\texttt{www.satcompetition.org}}}.
    
    \item Řešič v ukázce: \href{http://www.labri.fr/perso/lsimon/glucose/}{\myblue{\texttt{Glucose}}}, formát pro CNF soubory: \href{http://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html}{\myblue{\texttt{DIMACS}}}.
    
    \item Obecnější otázka: \emph{Lze celou matematiku převést do logických formulí?}
    
    AI, strojové dokazování, \myblue{Peano: \emph{Formulario}} (1895-1908), \myblue{Mizar system}
    
    \item \emph{Proč to lidé (většinou) nedělají?}
    
    Jak vyřešíme uvedený příklad \emph{elegantněji}? V čem náš postup spočívá?
\end{itemize}

% :from slides




\section{2-SAT a implikační graf}

Výrok $\varphi$ je v $k$-CNF, pokud je v CNF a každá klauzule má nejvýše $k$ literálů. Problému $k$-SAT se ptá, zda je daný $k$-CNF formule splnitelná. Pro $k\geq 3$ je $k$-SAT nadále NP-úplný, každou CNF formuli lze zakódovat do 3-CNF formule:

\begin{exercise}
Ukažte, že pro každý výrok $\varphi$ v CNF existuje \emph{ekvisplnitelný} výrok v $\varphi'$ 3-CNF (tj. $\varphi$ je splnitelný, právě když $\varphi'$ je splnitelný), který lze zkonstruovat v lineárním čase.
\end{exercise}

Pro problém 2-SAT ale existuje polynomiální (dokonce lineární) algoritmus, který si nyní představíme. Algoritmus využívá tzv.\ \emph{implikačního grafu}. Ukážeme si postup na příkladě:
\begin{example}
    Mějme následující 2-CNF výrok $\varphi$:
    $$
    (\neg p_1 \lor p_2) \land (\neg p_2 \lor \neg p_3) \land (p_1\lor p_3) \land (p_3\lor \neg p_4)\land (\neg p_1\lor p_5)\land (p_2\lor p_5)\land p_1\land \neg p_4
    $$
\end{example}

\subsubsection{Implikační graf}

Implikační graf 2-CNF výroku $\varphi$ je založený na myšlence, že 2-klauzuli $\ell_1\lor \ell_2$ (kde $\ell_1,\ell_2$ jsou literály) lze chápat jako dvojici implikací: $\overline{\ell_1}\limplies\ell_2$ a $\overline{\ell_2}\limplies \ell_1$.\footnote{V předchozí kapitole jsme vyjadřovali $p_1\limplies p_2$ jako $\neg p_1\lor p_2$, zde provádíme opačný postup.} Například, z klauzule $\neg p_1\lor p_2$ vzniknou implikace $p_1\limplies p_2$ a také $,\neg p_2\limplies \neg p_1$. Tedy pokud $p_1$ platí v nějakém modelu, musí platit i $p_2$, a pokud $p_2$ neplatí, nesmí platit ani $p_1$. Jednotkovou klauzuli $\ell$ můžeme také vyjádřit pomocí implikace jako $\overline{\ell}\limplies\ell$, např.\ z $p_1$ dostáváme $\neg p_1\limplies p_1$.

Implikační graf $\mathcal G_\varphi$ je tedy orientovaný graf, jehož vrcholy jsou všechny literály (proměnné z $\Var(\varphi)$ a jejich negace) a hrany jsou dané implikacemi popsanými výše: 
\begin{itemize}
    \item $V(\mathcal G_\varphi) = \{p, \neg p \mid p\in\Var(\varphi)\}$,
    \item $E(\mathcal G_\varphi) = \{(\overline{\ell_1},\ell_2), (\overline{\ell_2},\ell_1)\mid \ell_1\lor \ell_2\text{ je klauzule }\varphi\}\union\{(\overline{\ell},\ell)\mid \ell \text{ je jednotková klauzule }\varphi\}$
\end{itemize} 

V našem příkladě máme množinu vrcholů 
$$
V(\mathcal G_\varphi)=\{p_1,p_2,p_3,p_4,p_5,\neg p_1,\neg p_2,\neg p_3,\neg p_4,\neg p_5\}
$$ 
a hrany jsou:
\begin{align*}
    E(\mathcal G_\varphi)=\{&(p_1,p_2),(\neg p_2,\neg p_1),(p_2,\neg p_3),(p_3,\neg p_2),(\neg p_1,p_3),(\neg p_3,p_1),(\neg p_3,\neg p_4),
    \\&(p_4,p_3),(p_1,p_5),(\neg p_5,\neg p_1),(\neg p_2,p_5),(\neg p_5,p_2),(\neg p_1,p_1),(p_4,\neg p_4)\}
\end{align*}
Výsledný graf je znázorněný na Obrázku \ref{figure:implication-graph}.

\begin{figure} 
    \small   
    \centering
        \begin{tikzpicture}[scale=2,
            every node/.style={circle,fill=gray!5,draw,minimum width=1cm,node distance=2cm}
        ]
        \node[fill=red!10] (-5) {$\neg p_5$};
        \node[fill=blue!10,right of=-5] (-1) {$\neg p_1$};
        \node[fill=blue!10,above of=-1] (-2) {$\neg p_2$};
        \node[fill=blue!10,below of=-1] (3) {$p_3$};    
        \node[fill=green!10,left of=3] (4) {$p_4$};
        \node[fill=blue!70,right of=-1] (1) {$p_1$}; 
        \node[fill=blue!70,above of=1] (2) {$p_2$};
        \node[fill=blue!70,below of=1] (-3) {$\neg p_3$};       
        \node[fill=red!70,right of=1] (5) {$p_5$};            
        \node[fill=green!70,right of=-3] (-4) {$\neg p_4$};
        \draw[-{Latex[length=2.5mm]}] (-5) -- (-1);
        \draw[-{Latex[length=2.5mm]}] (-1) -- (3);
        \draw[-{Latex[length=2.5mm]}] (3) edge[bend right] (-2);
        \draw[-{Latex[length=2.5mm]}] (-2) -- (-1);
        \draw[-{Latex[length=2.5mm]}] (4) -- (3);
        \draw[-{Latex[length=2.5mm]}] (-1) -- (1);
        \draw[-{Latex[length=2.5mm]}] (-3) -- (1);
        \draw[-{Latex[length=2.5mm]}] (2) edge[bend left] (-3);
        \draw[-{Latex[length=2.5mm]}] (1) -- (2);
        \draw[-{Latex[length=2.5mm]}] (-5) edge[bend left=70] (2);
        \draw[-{Latex[length=2.5mm]}] (4) edge[bend right] (-4);
        \draw[-{Latex[length=2.5mm]}] (1) -- (5);
        \draw[-{Latex[length=2.5mm]}] (-2) edge[bend left=70] (5);
        \draw[-{Latex[length=2.5mm]}] (-3) -- (-4);
        \end{tikzpicture}
        \caption{Implikační graf $\mathcal G_\varphi$. Komponenty silné souvislosti jsou odlišeny barevně.}\label{figure:implication-graph}
\end{figure}

\subsection{Silně souvislé komponenty}

Nyní musíme najít komponenty silné souvislosti\footnote{\emph{Silná souvislost} znamená, že existuje orientovaná cesta z $u$ do $v$ i z $v$ do $u$, neboli každé dva vrcholy v jedné komponentě leží v orientovaném cyklu. A naopak, každý orientovaný cyklus leží uvnitř nějaké komponenty.} tohoto grafu. V našem příkladě dostáváme následující komponenty: $C_1=\{p_4\}$, $C_2=\{\neg p_5\}$, $C_3=\{\neg p_1,\neg p_2,p_3\}$, $\overline{C_3}=\{p_1,p_2,\neg p_3\}$, $\overline{C_2}=\{p_5\}$, $\overline{C_1}=\{\neg p_4\}$.

Všechny literály v jedné komponentě musí být ohodnoceny stejně. Pokud bychom tedy našli dvojici opačných literálů v jedné komponentě, znamená to, že výrok je nesplnitelný. V opačném případě vždy můžeme najít splňující ohodnocení, jak si dokážeme v Tvrzení \ref{proposition:2-sat-algorithm}. Potřebujeme zajistit, aby z žádné komponenty ohodnocené 1 nevedla hrana do komponenty ohodnocené 1. Provedeme-li kontrakci komponent, výsledný graf $\mathcal G_\varphi^\ast$ je acyklický (každý cyklus byl uvnitř nějaké komponenty), a můžeme ho tedy nakreslit v \emph{topologickém uspořádání} (tj.\ uspořádání na přímce, kde hrany vedou jen doprava), viz Obrázek \ref{figure:implication-graph-components}. 

\begin{figure} 
    \small   
    \centering
        \begin{tikzpicture}[scale=2,
            every node/.style={circle,fill=gray!5,draw,minimum width=1cm,node distance=2cm}
        ]
        \node[fill=red!10] (C1) {$C_1$};
        \node[fill=blue!10,below right of=C1] (C3) {$C_3$};
        \node[fill=green!10,below left of=C3] (C2) {$C_2$};
        \node[fill=blue!70,right of=C3] (barC3) {$\overline{C_3}$}; 
        \node[fill=red!70,above right of=barC3] (barC1) {$\overline{C_1}$};                    
        \node[fill=green!70,below right of=barC3] (barC2) {$\overline{C_2}$};
        \draw[-{Latex[length=2.5mm]}] (C1) -- (C3);
        \draw[-{Latex[length=2.5mm]}] (C2) -- (C3);
        \draw[-{Latex[length=2.5mm]}] (C3) -- (barC3);
        \draw[-{Latex[length=2.5mm]}] (barC3) -- (barC1);
        \draw[-{Latex[length=2.5mm]}] (barC3) -- (barC2);
        \draw[-{Latex[length=2.5mm]}] (C1) edge[bend left] (barC3);
        \draw[-{Latex[length=2.5mm]}] (C3) edge[bend left] (barC1);
        \draw[-{Latex[length=2.5mm]}] (C2) edge[bend right] (barC2);
        \end{tikzpicture}
        \caption{Implikační graf $\mathcal G_\varphi$. Graf silně souvislých komponent $\mathcal G_\varphi^\ast$.}\label{figure:implication-graph-components}
\end{figure}

Při hledání splňujícího ohodnocení (pokud nám nestačí informace, že výrok je splnitelný) potom postupujeme tak, že vezmeme nejlevější dosud neohodnocenou komponentu, ohodnotíme ji 0, opačnou komponentu ohodnotíme 1, a postup opakujeme dokud zbývá nějaká neohodnocená komponenta. Například, topologické uspořádání na Obrázku \ref{figure:implication-graph-topological-order} odpovídá modelu $v=(1,1,0,0,1)$.

\begin{figure} 
    \small   
    \centering
        \begin{tikzpicture}[scale=2,
            every node/.style={circle,fill=gray!5,draw,minimum width=1cm,node distance=2cm}
        ]
        \node[fill=red!10,label={below:0}] (C1) {$C_1$};
        \node[fill=green!10,right of=C1,label={below:0}] (C2) {$C_2$};
        \node[fill=blue!10,right of=C2,label={below:0}] (C3) {$C_3$};
        \node[fill=blue!70,right of=C3,label={below:1}] (barC3) {$\overline{C_3}$}; 
        \node[fill=green!70,right of=barC3,label={below:1}] (barC2) {$\overline{C_2}$};
        \node[fill=red!70,right of=barC2,label={below:1}] (barC1) {$\overline{C_1}$};                    
        
        \draw[-{Latex[length=2.5mm]}] (C1) edge[bend left] (C3);
        \draw[-{Latex[length=2.5mm]}] (C2) -- (C3);
        \draw[-{Latex[length=2.5mm]}] (C3) -- (barC3);
        \draw[-{Latex[length=2.5mm]}] (barC3) edge[bend left] (barC1);
        \draw[-{Latex[length=2.5mm]}] (barC3) -- (barC2);
        \draw[-{Latex[length=2.5mm]}] (C1) edge[bend left] (barC3);
        \draw[-{Latex[length=2.5mm]}] (C3) edge[bend left] (barC1);
        \draw[-{Latex[length=2.5mm]}] (C2) edge[bend left] (barC2);
        \end{tikzpicture}
        \caption{Implikační graf $\mathcal G_\varphi$. Topologické uspořádání grafu $\mathcal G_\varphi^\ast$ a splňující ohodnocení komponent.}\label{figure:implication-graph-topological-order}
\end{figure}

Na závěr shrneme naše úvahy do následujícího tvrzení:

\begin{proposition}\label{proposition:2-sat-algorithm}
    Výrok $\varphi$ je splnitelný, právě když žádná silně souvislá komponenta v $\mathcal G_\varphi$ neobsahuje dvojici opačných literálů $\ell,\overline{\ell}$.
\end{proposition}

\begin{proof}
    Každý model, neboli splňující ohodnocení, musí ohodnotit všechny literály ze stejné komponenty stejnou hodnotou. (V opačném případě by nutně existovala implikace $\ell_1\limplies\ell_2$, kde $\ell_1$ v modelu platí ale $\ell_2$ neplatí.) V jedné komponentě tedy nemohou být opačné literály.

    Naopak předpokládejme, že žádná komponenta neobsahuje dvojici opačných literálů, a ukažme, že potom existuje model. Označme $\mathcal G_\varphi^\ast$ graf vzniklý z $\mathcal G_\varphi$ kontrakcí silně souvislých komponent. Tento graf je acyklický, zvolme nějaké topologické uspořádání. Model zkonstruujeme tak, že zvolíme první dosud neohodnocenou komponentu v našem topologickém uspořádání, všechny literály v ní obsažené ohodnotíme 0, a opačné literály ohodnotíme 1. Takto pokračujeme dokud nejsou všechny komponenty ohodnoceny.

    Proč v takto získaném modelu platí výrok $\varphi$? Kdyby ne, neplatila by některá z klauzulí. Jednotková klauzule $\ell$ musí platit, neboť v grafu $\mathcal G_\varphi$ máme hranu $\overline{\ell}\limplies\ell$. Stejná hrana je i v grafu komponent, tedy $\overline{\ell}$ předchází v topologickém uspořádání komponentu obsahující $\ell$. Při konstrukci modelu jsme museli ohodnotit $\overline{\ell}$ dříve než $\ell$, tedy $\overline{\ell}=0$ a $\ell=1$. Podobně, 2-klauzule $\ell_1\lor\ell_2$ také musí platit: máme hrany $\overline{\ell_1}\limplies\ell_2$ a $\overline{\ell_2}\limplies\ell_1$. Pokud jsme $\ell_1$ ohodnotili dříve než $\ell_2$, museli jsme kvůli hraně $\overline{\ell_1}\limplies\ell_2$ ohodnotit $\overline{\ell_1}=0$, tedy $\ell_1$ platí. Podobně pokud jsme ohodnotili nejdříve $\ell_2$, musí být $\overline{\ell_2}=0$ a $\ell_2=1$. 
\end{proof}

\begin{corollary}
    Problém 2-SAT je řešitelný v lineárním čase. V lineárním čase můžeme také zkonstruovat model, pokud existuje.
\end{corollary}

\begin{proof}
Komponenty silné souvislosti lze snadno nalézt v v čase $\mathcal O(|V|+|E|)$, topologické uspořádání můžeme také zkonstruovat v čase $\mathcal O(|V|+|E|)$.
\end{proof}

\begin{exercise}
    Najděte nějaký nesplnitelný 2-CNF výrok, sestrojte jeho implikační graf, a přesvědčete se, že existuje dvojice opačných literálů ve stejné komponentě silné souvislosti.
\end{exercise}

\begin{exercise}
    Najděte všechna topologická uspořádání grafu $\mathcal G_\varphi^\ast$ z příkladu výše a jim odpovídající modely. Rozmyslete si, proč takto získáme právě všechny modely výroku $\varphi$.
\end{exercise}

\begin{exercise}
    Rozmyslete si, proč lze komponenty i topologické uspořádání nalézt v čase $\mathcal O(|V|+|E|)$.
\end{exercise}

\section{Horn-SAT a jednotková propagace}\label{section:horn-sat}

Nyní si ukážeme další fragment SATu řešitelný v polynomiálním čase, tzv.\ \emph{Horn-SAT} neboli problém splnitelnosti \emph{hornovských výroků}. Výrok je v \emph{hornovský (v Hornově tvaru)}\footnote{Matematik Alfred Horn objevil význam tohoto tvaru logických formulí (a položil tak základ logickému programování) v roce 1951.}, pokud je konjunkcí \emph{hornovských klauzulí}, tj. klauzulí obsahujících \emph{nejvýše jeden *pozitivní* literál}. Význam Hornovských klauzulí vyplývá z ekvivalentního vyjádření ve formě implikace:
$$
\neg p_1\lor \neg p_2\lor \dots \lor \neg p_n\lor q\ \sim\ (p_1\land p_2\land\dots \land p_n)\limplies q
$$
Hornovské formule tedy dobře modelují systémy, kde splnění určitých podmínek zaručuje splnění jiné podmínky. Upozorněme, že jednotková klauzule $\ell$ je také hornovská. V kontextu logického programování se jí říká \emph{fakt}, pokud je literál pozitivní, a \emph{cíl} pokud je negativní.\footnote{Neboť dokazujeme sporem, více v pozdější kapitole o rezoluci a Prologu.} Hornovské formule s alespoň jedním pozitivním a alespoň jedním negativním literálem jsou \emph{pravidla}. 

\begin{example}
    Příkladem výroku, který je v CNF, ale není hornovský, je třeba $(p_1\lor p_2\lor\neg p_3)\land (\neg p_1\lor p_3)$. Jako příklad, na kterém budeme ilustrovat algoritmus, nám poslouží následující hornovský výrok:
    $$
    \varphi=(\neg p_1\lor p_2)\land(\neg p_1\lor\neg p_2\lor p_3)\land(\neg _3\lor\neg p_4)\land(\neg p_5\lor \neg p_4)\land p_4
    $$
\end{example}

Polynomiální algoritmus pro řešení problému Horn-SAT je založený na jednoduché myšlence \emph{jednotkové propagace}: Pokud náš výrok obsahuje \emph{jednotkovou} klauzuli, víme, jak musí být ohodnocenena výroková proměnná obsažená v této klauzuli. A tuto znalost můžeme \emph{propagovat}---využít k zjednodušení výroku. 

Náš výrok $\varphi$ obsahuje jednotkovou klauzuli $p_4$. Víme tedy, že v každém jeho modelu $v\in\M(\varphi)$ musí platit $v(p_4)=1$. To ale znamená, že v libovolném modelu výroku $\varphi$
\begin{itemize}
    \item každá klauzule obsahující pozitivní literál $p_4$ je splněna, můžeme ji tedy z výroku odstranit,
    \item negativní literál $\neg p_4$ nemůže být splněn, můžeme ho tedy odstranit ze všech klauzulí, které ho obsahují. 
\end{itemize}
Tomu kroku se říká \emph{jednotková propagace}. Výsledkem je následující zjednodušený výrok, který označíme $\varphi^{p_4}$ (obecně $\varphi^\ell$ máme-li jednotkovou klauzuli $\ell$):
$$
\varphi^{p_4}=(\neg p_1\lor p_2)\land(\neg p_1\lor\neg p_2\lor p_3)\land(\neg _3\lor\neg p_4)\land\neg p_5
$$
\begin{observation}
Všimněte si, že $\varphi^\ell$ už neobsahuje literál $\ell$ ani $\overline{\ell}$, a zřejmě platí, že modely $\varphi$ jsou právě modely $\{\varphi^{\ell},\ell\}$, neboli modely $\varphi^{\ell}$ v původním jazyce $\mathbb P$, ve kterých platí $\ell$.
\end{observation}

Jednotkovou propagací jsme získali ve výroku $\varphi^{p_4}$ novou jednotkovou klauzuli $\neg p_5$, můžeme tedy pokračovat nastavením $v(p_5)=0$ a další jednotkovou propagací:
$$
(\varphi^{p_4})^{\neg p_5}=(\neg p_1\lor p_2)\land(\neg p_1\lor\neg p_2\lor p_3)\land(\neg p_3\lor\neg p_4)
$$
Výsledný výrok už neobsahuje jednotkovou klauzuli. To ale znamená, že každá klauzule obsahuje alespoň dva literály, a nejvýše jeden z nich může být pozitivní! (Zde potřebujeme hornovskost výroku.) Protože každá klauzule obsahuje negativní literál, stačí ohodnotit všechny zbývající proměnné 0, a výrok bude splněn: $v(p_1)=v(p_2)=v(p_3)=0$. Dostáváme tedy model $v=(0,0,0,1,1)$.

\begin{example}
    Co by se stalo, pokud by výrok nebyl splnitelný? Podívejme se na výrok 
    $$
    \psi=p\land (\neg p\lor q)\land (\neg q\lor r)\lor\neg r
    $$ 
    a provádějme jednotkovou propagaci jako v předchozím příkladě: máme $v(p)=1$ a 
$\psi^p=q\land (\neg q\lor r)\lor\neg r$, dále $v(q)=1$ a $(\psi^p)^q=r\lor\neg r$. 
Tento výrok je nesplnitelný, neboť obsahuje dvojici opačných jednotkových klauzulí. \footnote{Jinými slovy, v dalším kroku bychom provedli jednotkovou propagaci $r$, odstranili jednotkovou klauzuli $r$, a ze zbývající jednotkové klauzule $\neg r$ bychom odstranili literál $\neg r$, čímž by vznikla \emph{prázdná klauzule}, která je nesplnitelná.}
\end{example}

Shrňme si nyní algoritmus pro řešení problému Horn-SAT: 

\begin{algorithm}[Horn-SAT]
\textbf{vstup}: Vstup: výrok $\varphi$ v Hornově tvaru, výstup: model $\varphi$ nebo informace, že  $\varphi$ není splnitelný
\begin{enumerate}
    \item Pokud $\varphi$ obsahuje dvojici opačných jednotkových klauzulí $\ell,\overline{\ell}$, není splnitelný.
    \item Pokud $\varphi$ neobsahuje žádnou jednotkovou klauzuli, je splnitelný, ohodnoť všechny zbývající proměnné 0.
    \item Pokud $\varphi$ obsahuje jednotkovou klauzuli $\ell$, ohodnoť literál $\ell$ hodnotou 1, proveď jednotkovou propagaci, nahraď $\varphi$ výrokem $\varphi^\ell$, a vrať se na začátek.
\end{enumerate}
\end{algorithm}

\begin{proposition}
Algoritmus je korektní.    
\end{proposition}
\begin{proof}
Korektnost plyne z Pozorování a z předchozí diskuze.
\end{proof}

\begin{corollary}
    Horn-SAT lze řešit v lineárním čase.
\end{corollary}

\begin{proof}
V každém kroku stačí projít výrok jednou, a jednotková propagace výrok vždy zkrátí. Z toho snadno plyne kvadratický horní odhad, ale při vhodné implementaci lze dosáhnout lineárního času vzhledem k délce $\varphi$.
\end{proof}


\begin{exercise}
Navrhněte implementaci algoritmu pro Horn-SAT v lineárním čase.
\end{exercise}

\begin{exercise}
Navrhněte modifikaci algoritmu pro Horn-SAT, která najde všechny modely.
\end{exercise}


\section{DPLL algoritmus pro řešení problému SAT}\label{section:DPLL}

Na závěr kapitoly o problému splnitelnosti si představíme zdaleka nejpoužívanější algoritmus pro řešení obecného problému SAT, algoritmus DPLL.\footnote{Pojmenovaný po svých tvůrcích, Davis-Putnam-Logemann-Loveland, pochází z roku 1961.} Ačkoliv v nejhorším případě má exponenciální složitost, v praxi funguje velmi efektivně.

Algoritmus používá jednotkovou propagaci spolu s následujícím pozorováním: Řekneme, že literál $\ell$ má \emph{čistý výskyt} v $\varphi$, pokud se vyskytuje ve $\varphi$, ale opačný literál $\overline{\ell}$ se ve $\varphi$ nevyskytuje. Máme-li literál s čistým výskytem, můžeme jeho hodnotu nastavit na 1, a splnit (a odstranit) tak všechny klauzule, které ho obsahují. Pokud výrok neumíme takto zjednodušit, rozvětvíme výpočet dosazením obou možných hodnot pro vybranou výrokovou proměnnou.

\begin{algorithm}[DPLL]
    \textbf{vstup}: Vstup: výrok $\varphi$ v CNF, výstup: model $\varphi$ nebo informace, že  $\varphi$ není splnitelný
    \begin{enumerate}                
        \item Dokud $\varphi$ obsahuje jednotkovou klauzuli $\ell$, ohodnoť literál $\ell$ hodnotou 1, proveď jednotkovou propagaci, a nahraď $\varphi$ výrokem $\varphi^\ell$.
         \item Dokud existuje literál $\ell$, který má ve $\varphi$ čistý výskyt, ohodnoť $\ell$ hodnotou 1, a odstraň klauzule obsahující $\ell$.
        \item Pokud $\varphi$ neobsahuje žádnou klauzuli, je splnitelný.
        \item Pokud $\varphi$ obsahuje prázdnou klauzuli, není splnitelný.
        \item Jinak zvol dosud neohodnocenou výrokovou proměnnou $p$, a zavolej algoritmus rekurzivně na $\varphi\land p$ a na $\varphi\land \neg p$.
    \end{enumerate}
\end{algorithm}

To, že je algoritmus v nejhorším případě exponenciální, lze snadno nahlédnout na příkladě jediné klauzule $p_1\lor p_2\lor\dots\lor p_n$. Korektnost není těžké ověřit.

\begin{proposition}
    Algoritmus DPLL řeší problém SAT.
\end{proposition}
    
\begin{example}
    Ukážeme si běh algoritmu na následujícím příkladě:
    $$
    (\neg p\lor q\lor \neg r)\land(\neg p\lor\neg q\lor\neg s)\land(p\lor \neg r\lor \neg s)\land(q\lor \neg r\lor s)\land (p\lor s)\land(p\lor\neg s)\land(q\lor s)
    $$
    Výrok nemá žádnou jednotkovou klauzuli. Literál $\neg r$ má čistý výskyt, nastavíme  $v(r)=0$ a odstraníme klauzule obsahující $\neg r$:
    $$
    (\neg p\lor\neg q\lor\neg s)\land (p\lor s)\land(p\lor\neg s)\land(q\lor s)
    $$
    Žádný další literál nemá čistý výskyt. Spustíme proto rekurzivně algoritmus:
    \begin{itemize}
        \item[(p=1)] Přidáme jednotkovou klauzuli $p$:
        $$
        (\neg p\lor\neg q\lor\neg s)\land (p\lor s)\land(p\lor\neg s)\land(q\lor s)\land p
        $$
        Nastavíme $v(p)=1$ a provedeme jednotkovou propagaci: $(\neg q\lor\neg s)\land(q\lor s)$. Nyní rozvětvíme na proměnné $q$:
        \begin{itemize}
            \item[(q=1)] $(\neg q\lor\neg s)\land(q\lor s)\land q$. Po nastavení $v(q)=1$ a jednotkové propagaci dostáváme $s$, po nastavení $v(s)=1$ a jednotkové propagaci dostáváme výrok neobsahující žádnou klauzuli, je tedy splnitelný ohodnocením $(1,1,0,*,*)$. Odpověď na problém splnitelnosti už máme, pokud chceme znát všechny modely, můžeme dokončit ostatní větve výpočtu.
            \item[(q=0)] $(\neg q\lor\neg s)\land(q\lor s)\land \neg q$. Dostáváme modely $(1,0,0,*,*)$.
            
        \end{itemize}
        \item[(p=0)] Přidáme jednotkovou klauzuli $\neg p$:
        $$
        (\neg p\lor\neg q\lor\neg s)\land (p\lor s)\land(p\lor\neg s)\land(q\lor s)\land \neg p
        $$
        Po provedení jednotkové propagace $\neg p$ máme $s\land \neg s\land(q\lor s)$. Po provedení jednotkové propagace $s$ máme $\square\land q$, kde $\square$ je prázdná klauzule. Výrok je tedy nesplnitelný a v této větvi nedostaneme žádné modely. 
    \end{itemize}

Zjistili jsme, že původní výrok je splnitelný, má 8 modelů, konkrétně: $\M_\varphi=\{(1,a,0,b,c)\mid a,b,c\in\{0,1\},\}$.\footnote{To znamená, že je ekvivalentní výroku $p\land \neg r$.}
    
\end{example}