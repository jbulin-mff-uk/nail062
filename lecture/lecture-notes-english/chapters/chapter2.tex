\chapter{Syntax and Semantics of Propositional Logic}

\emph{Syntax} is a set of formal rules for creating well-formed sentences consisting of words (in the case of natural languages) or formal expressions consisting of symbols (e.g., statements in a programming language). In contrast, \emph{semantics} describes the meaning of such expressions. The relationship between syntax and semantics is fundamental to all of logic and is therefore the key to its understanding.

\section{Syntax of Propositional Logic}

First, we define the formal `statements' with which we will work in propositional logic.

\subsection{Language}

The \emph{language} of propositional logic is determined by a non-empty set of \emph{propositional variables} \( \mathbb P \) (also called \emph{atomic propositions} or \emph{atoms}). This set can be finite or infinite, but it will usually be countable\footnote{This is important in many applications in computer science, as uncountable sets cannot fit into a (even infinite) computer.} (unless otherwise specified), and it will have a fixed ordering. For propositional variables, we will typically use the notation \( p_i \) (from the word ``proposition''), but for better readability, especially if \( \mathbb P \) is finite, we will also use \( p, q, r, \dots \). For example:
\begin{align*}
    \mathbb P_1 &= \{ p, q, r \} \\
    \mathbb P_2 &= \{ p_0, p_1, p_2, p_3, \ldots \} = \{ p_i \mid i \in \mathbb{N} \}
\end{align*}

In addition to propositional variables, the language also includes \emph{logical symbols}: symbols for logical connectives \( \neg, \land, \lor, \limplies, \liff \) and parentheses \( (, ) \). However, for simplicity, we will talk about the ``language~\( \mathbb P \)''.

\begin{remark}\label{remark:order-of-language}
If we need to formally express the ordering of the propositional variables in $\mathbb P$, we imagine it as a bijection $\iota\colon\{0, 1, \dots, n-1\}\to \mathbb P$ (for a finite, $n$-element language) or $\iota\colon\mathbb{N}\to \mathbb P$ (if $\mathbb P$ is countably infinite). In our examples, $\iota_1(0)=p$, $\iota_1(1)=q$, $\iota_1(2)=r$, and $\iota_2(i)=p_i$ for all $i\in\mathbb{N}$.\footnote{The set of natural numbers $\mathbb{N}$ includes zero, see standard ISO 80000-2:2019.}
\end{remark}

\subsection{Proposition}

The basic building block of propositional logic is a \emph{proposition}, also called \emph{propositional formula}. It is a finite string composed of propositional variables and logical symbols according to certain rules. Atomic propositions are propositions, and we can further create propositions from simpler propositions and logical symbols: for example, for the logical connective $\land$, we write first the symbol `(', then the first proposition, the symbol `$\land$', the second proposition, and finally the symbol `)'.
\begin{definition}[Proposition]\label{definition:proposition}
    A \emph{proposition} (\emph{propositional formula}) in the language $\mathbb P$ is an element of the set $\VF_\mathbb P$ defined as follows: $\VF_\mathbb P$ is the smallest set satisfying\footnote{This kind of definition is called \emph{inductive}. It can also be naturally expressed using a \emph{formal grammar}, see the course \href{https://is.cuni.cz/studium/predmety/index.php?do=predmet&kod=NTIN071}{NTIN071 Automata and Grammars}.}
    \begin{itemize}
        \item for every atomic proposition $p\in\mathbb P$, $p\in\VF_\mathbb P$,
        \item for every proposition $\varphi\in\VF_\mathbb P$, $(\neg\varphi)$ is also an element of $\VF_\mathbb P$,
        \item for every $\varphi,\psi\in\VF_\mathbb P$, $(\varphi\land\psi)$, $(\varphi\lor\psi)$, $(\varphi\limplies\psi)$, and $(\varphi\liff\psi)$ are also elements of $\VF_\mathbb P$.
    \end{itemize}        
\end{definition}
Propositions are usually denoted by Greek letters $\varphi, \psi, \chi$ ($\varphi$ from the word ``formula''). To avoid listing all four binary logical connectives, we sometimes use a placeholder symbol $\lbinsymb$. Thus, the third point of the definition could be expressed as:
\begin{itemize}
    \item for every $\varphi,\psi\in\VF_\mathbb P$ and $\lbinsymb\in\{\land, \lor, \limplies, \liff\}$, $(\varphi\lbin\psi)$ is also an element of $\VF_\mathbb P$.
\end{itemize}  

A \emph{subproposition} (\emph{subformula}) is a substring that is itself a proposition. Note that all propositions are necessarily finite strings, created by applying a finite number of steps from the definition to their subpropositions.

\begin{example}\label{example:proposition}
The proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$ has the following subpropositions: $p, q, (\neg q), (p \lor (\neg q)), r, (p \land q), (r \limplies (p \land q)), \varphi$.
\end{example}

A proposition in the language $\mathbb P$ does not have to contain all atomic propositions from $\mathbb P$ (and it cannot if $\mathbb P$ is an infinite set). Therefore, it will be useful to denote by $\Var(\varphi)$ the set of atomic propositions occurring in $\varphi$.\footnote{If we do not specify the language of a proposition (and if it is not clear from the context), we mean that it is in the language $\Var(\varphi)$.} In our example, $\Var(\varphi)=\{p, q, r\}$.

We introduce abbreviations for two special propositions: $\top = (p \lor (\neg p))$ (\emph{tautology}) and $\bot = (p \land (\neg p))$ (\emph{contradiction}), where $p \in \mathbb P$ is fixed (e.g., the first atomic proposition from $\mathbb P$). Thus, the proposition~$\top$ is always true, and the proposition~$\bot$ is always false.

When writing propositions, we may omit some parentheses for better readability. For example, the proposition $\varphi$ from Example~\ref{example:proposition} can be represented by the string
$p \lor \neg q \liff (r \limplies p \land q)$. We omit outer parentheses and use priority of operators: $\neg$ has the highest priority, followed by $\land, \lor$, and finally $\limplies, \liff$ have the lowest priority. Furthermore, the notation $p \land q \land r \land s$ means the proposition $(p \land (q \land (r \land s)))$, and similarly for $\lor$.\footnote{Due to the associativity of $\land, \lor$, the placement of parentheses does not matter.}\footnote{Sometimes finer priorities are introduced, $\land$ often has higher priority than $\lor$, and $\limplies$ has higher priority than $\liff$. Also, sometimes $p \limplies q \limplies r$ is written instead of $(p \limplies (r \limplies q))$, although $\limplies$ is not associative and so here the placement of parentheses does matter. We prefer to avoid both of those conventions.}

\subsection{Tree of a Proposition}

In the definition of a proposition, we chose \emph{infix} notation (with parentheses) purely for human readability. Nothing would prevent us from using \emph{prefix} (``Polish'') notation, i.e., defining propositions as follows:
\begin{itemize}
    \item every atomic proposition is a proposition, and
    \item if $\varphi, \psi$ are propositions, then $\neg \varphi$, $\land \varphi \psi$, $\lor \varphi \psi$, $\limplies \varphi \psi$, and $\liff \varphi \psi$ are also propositions.
\end{itemize}
The proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$ would then be written as $\varphi = \liff \lor p \neg q \limplies r \land p q$. We could also use \emph{postfix} notation and write $\varphi = p q \neg \lor r p q \land \limplies \liff$. The essential information about a proposition is actually contained in its tree structure, which captures how it is composed of simpler propositions, similar to the tree of an arithmetic expression.

\begin{example}\label{example:tree}
The tree of the proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$ is illustrated in Figure~\ref{figure:tree-of-proposition}.
\begin{figure}
\centering
    \begin{forest}
        for tree={circle,draw=blue!20,fill=blue!10,minimum size=24pt}
        [$\liff$ [$\lor$ [$p$] [$\neg$ [$q$]]] [$\limplies$ [$r$] [$\land$ [$p$] [$q$]]]]
    \end{forest}
    \caption{Tree of the proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$}\label{figure:tree-of-proposition}
\end{figure}
Notice also how the subpropositions of $\varphi$ correspond to subtrees. The proposition $\varphi$ is obtained by traversing the tree from the root, and at each node:
\begin{itemize} 
    \item if the label is an atomic proposition, write it out,  
    \item if the label is a negation: write `($\neg$', recursively call the child, write `)',   
    \item otherwise (for binary logical connectives):
    write `(', call the left child, write the label, call the right child, write `)'.\footnote{Prefix and postfix notations would be obtained similarly, but we do not write parentheses, and the label is written immediately upon entering or just before leaving the node.}
\end{itemize}
\end{example}

Now we will define the tree of a proposition formally, \emph{by induction on the structure of the proposition}:\footnote{Once we have the tree of a proposition defined, we can understand induction on the structure of the proposition as induction on the depth of the tree. For now, understand it as induction on the number of steps in Definition~\ref{definition:proposition} by which the proposition was created. Alternatively, induction on the length of the proposition or the number of logical connectives would work as well.}

\begin{definition}[Tree of a Proposition]
    The \emph{tree of a proposition} $\varphi$, denoted $\Tree(\varphi)$, is a rooted ordered tree, defined inductively as follows: 
    \begin{itemize}
        \item If $\varphi$ is an atomic proposition $p$, $\Tree(\varphi)$ contains a single node, and its label is $p$.
        \item If $\varphi$ is of the form $(\neg \varphi')$, $\Tree(\varphi)$ has a root labeled $\neg$, and its single child is the root of $\Tree(\varphi')$.
        \item If $\varphi$ is of the form $(\varphi' \lbin \varphi'')$ for $\lbinsymb \in \{\land, \lor, \limplies, \liff\}$, $\Tree(\varphi)$ has a root labeled $\lbinsymb$ with two children: the left child is the root of the tree $\Tree(\varphi')$, and the right child is the root of $\Tree(\varphi'')$.
    \end{itemize}
\end{definition}

\begin{exercise}
    Prove that every proposition has a uniquely determined proposition tree, and vice versa.
\end{exercise}

\subsection{Theory}

In practical applications, we do not express the desired properties with a single proposition — it would have to be very long and complex and difficult to work with — but with many simpler propositions.

\begin{definition}[Theory]\label{definition:theory}
    A \emph{theory} in the language $\mathbb P$ is any set of propositions in $\mathbb P$, that is, any subset $T \subseteq \VF_\mathbb P$. The individual propositions $\varphi \in T$ are also called \emph{axioms}.
\end{definition}

\emph{Finite} theories could be replaced by a single proposition: the conjunction of all their axioms. But that would not be practical. Moreover, we also allow infinite theories (a trivial example is the theory $T = \VF_\mathbb P$), and the empty theory $T = \emptyset$.\footnote{Infinite theories are useful, for example, for describing the development of a system over (discrete) time steps $t = 0, 1, 2, \dots$. The empty theory is not useful for anything, but it would be awkward to formulate statements about logic if theories had to be non-empty.}


\section{Semantics of Propositional Logic}

In our logic, the semantics are given by one of two possible values: \emph{True} or \emph{False}. (In other logical systems, semantics can be more interesting.)


\subsection{Truth Value}

Propositions can be assigned one of two possible truth values: \emph{True} (1) or \emph{False} (0). Atomic propositions represent simple, indivisible statements (hence the name `\emph{atomic}'); their truth value must be assigned to correspond to what we want to model (that is why we call them \emph{propositional variables}). Once we \emph{assign} truth values to the atomic propositions, the truth value of any compound proposition is uniquely determined and can be easily calculated according to the tree of the proposition:

\begin{example}\label{example:truth-value}
Let us calculate the truth value of the proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$ for the assignments (a) $p = 0$, $q = 0$, $r = 0$ and (b) $p = 1$, $q = 0$, $r = 1$. We proceed from the leaves towards the root, similarly to evaluating an arithmetic expression. The proposition $\varphi$ is \emph{true} under assignment (a) and \emph{false} under assignment (b). See Figure~\ref{figure:truth-value}.

\begin{figure}
\tikzset{every label/.style = {text=red}}
\begin{minipage}{.49\textwidth}
    \centering
    
    \begin{forest}
        for tree={circle,draw=blue!20,fill=blue!10,minimum size=24pt},        
        [$\liffsymb$, label=1
            [$\lorsymb$, label={above left:1}
                [$p$, label={[text=blue]below:0}] 
                [$\neg$, label={above:1}  
                    [$q$, label={[text=blue]below:0}]
                ]
            ] 
            [$\limpliessymb$, label={above right:1} 
                [$r$, label={[text=blue]below:0}] 
                [$\landsymb$, label={above right:0} 
                    [$p$, label={[text=blue]below:0}] 
                    [$q$, label={[text=blue]below:0}]
                ]
            ]
        ]
    \end{forest}   

    (a) $p = 0$, $q = 0$, $r = 0$
\end{minipage}
\begin{minipage}{.49\textwidth}
    \centering
    \begin{forest}
        for tree={circle,draw=blue!20,fill=blue!10,minimum size=24pt},        
        [$\liffsymb$, label=0
            [$\lorsymb$, label={above left:1}
                [$p$, label={[text=blue]below:1}] 
                [$\neg$, label={above:1}  
                    [$q$, label={[text=blue]below:0}]
                ]
            ] 
            [$\limpliessymb$, label={above right:0} 
                [$r$, label={[text=blue]below:1}] 
                [$\landsymb$, label={above right:0} 
                    [$p$, label={[text=blue]below:1}] 
                    [$q$, label={[text=blue]below:0}]
                ]
            ]
        ]
    \end{forest}

    (b) $p = 1$, $q = 0$, $r = 1$
\end{minipage}
\caption{Truth value of a proposition}
\label{figure:truth-value}
\end{figure}
\end{example}
        
Logical connectives in the inner nodes are evaluated according to their \emph{truth tables}, see Table~\ref{table:logical-connectives}.\footnote{Let us recall once again that disjunction is not exclusive, i.e., $p \lor q$ is true even if both $p$ and $q$ are true, and that implication is purely logical, i.e., $p \limplies q$ is true whenever $p$ is false.}

\begin{table}[htbp]
    \centering
    \begin{tabular}{@{}cc|ccccc@{}}
        \toprule
        $p$ & $q$ & $\neg p$ & $p \land q$ & $p \lor q$ & $p \limplies q$ & $p \liff q$ \\ \midrule
        0   & 0   & 1        & 0          & 0         & 1          & 1          \\
        0   & 1   & 1        & 0          & 1         & 1          & 0          \\
        1   & 0   & 0        & 0          & 1         & 0          & 0          \\
        1   & 1   & 0        & 1          & 1         & 1          & 1          \\ \bottomrule
    \end{tabular}
    \caption{Truth tables of logical connectives.}
    \label{table:logical-connectives}
\end{table}

\subsection{Propositions and Boolean Functions}

To formalize the truth value of a proposition, we first look at the relationship between propositions and Boolean functions. 

A \emph{Boolean function} is a function $f\colon\{0,1\}^n\to\{0,1\}$, meaning that the input is an $n$-tuple of zeros and ones, and the output is 0 or 1. Each logical connective represents a Boolean function. In the case of negation, it is a unary function $f_\neg(x)=1-x$, while the other logical connectives correspond to binary functions described in Table~\ref{table:boolean-functions-for-logical-connectives}.

\begin{table}
\centering
$f_\landsymb(x,y)$:  
\begin{tabular}{c|cc}
      & 0 & 1  \\ \hline
    0 & 0 & 0  \\
    1 & 0 & 1 
\end{tabular}\quad
$f_\lorsymb(x,y)$:         
\begin{tabular}{c|cc}
      & 0 & 1  \\ \hline
    0 & 0 & 1  \\
    1 & 1 & 1 
\end{tabular}\quad
$f_\limpliessymb(x,y)$:         
\begin{tabular}{c|cc}
      & 0 & 1  \\ \hline
    0 & 1 & 1  \\
    1 & 0 & 1 
\end{tabular}\quad
$f_\liffsymb(x,y)$:         
\begin{tabular}{c|cc}
      & 0 & 1  \\ \hline
    0 & 1 & 0  \\
    1 & 0 & 1 
\end{tabular}
\caption{Boolean functions of logical connectives}
\label{table:boolean-functions-for-logical-connectives}    
\end{table}

\begin{definition}[Truth Function]\label{definition:truth-function}
The \emph{truth function} of a proposition $\varphi$ in a finite language $\mathbb P$ is the function $f_{\varphi,\mathbb P}\colon\{0,1\}^{|\mathbb P|}\to\{0,1\}$ defined inductively:
\begin{itemize}
    \item If $\varphi$ is the $i$-th atomic proposition from $\mathbb P$, then $f_{\varphi,\mathbb P}(x_0,\dots,x_{n-1})=x_i$,
    \item If $\varphi = (\neg \varphi')$, then 
    $$
    f_{\varphi,\mathbb P}(x_0,\dots,x_{n-1}) = f_\neg(f_{\varphi',\mathbb P}(x_0,\dots,x_{n-1})),
    $$
    \item If $\varphi = (\varphi' \lbin \varphi'')$ where $\lbinsymb \in \{\land, \lor, \limplies, \liff\}$, then 
    $$
    f_{\varphi,\mathbb P}(x_0,\dots,x_{n-1}) = f_\lbinsymb(f_{\varphi',\mathbb P}(x_0,\dots,x_{n-1}), f_{\varphi'',\mathbb P}(x_0,\dots,x_{n-1})).
    $$
\end{itemize}
\end{definition}

\begin{example}
    Let us calculate the truth function of the proposition $\varphi = ((p \lor (\neg q)) \liff (r \limplies (p \land q)))$ in the language $\mathbb P'=\{p,q,r,s\}$:
    $$        
    f_{\varphi,\mathbb P'}(x_0,x_1,x_2,x_3)=f_\liffsymb(f_\lorsymb(x_0,f_\neg(x_1)),f_\limpliessymb(x_2,f_\landsymb(x_0,x_1)))    
    $$
    Truth value of the proposition $\varphi$ for the truth assignment $p=1$, $q=0$, $r=1$, $s=1$ is calculated as follows (compare with Figure \ref{figure:truth-value}(b)):
    \begin{align*}
    f_{\varphi,\mathbb P'}(1,0,1,1)
        &=f_\liffsymb(f_\lorsymb(1,f_\neg(0)),f_\limpliessymb(1,f_\landsymb(1,0))) \\
        &=f_\liffsymb(f_\lorsymb(1,1),f_\limpliessymb(1,0))\\
        &=f_\liffsymb(1,0)\\
        &=0
    \end{align*}
\end{example}

\begin{observation}
The truth function of a proposition $\varphi$ over $\mathbb P$ depends only on the variables corresponding to the atomic propositions in $\Var(\varphi)\subseteq\mathbb P$.
\end{observation}

Thus, even if we have a proposition $\varphi$ in an \emph{infinite} language $\mathbb P$, we can restrict ourselves to the language $\Var(\varphi)$ (which is finite) and consider the truth function over this language. 

\subsection{Models}

A given truth assignment of propositional variables is a representation of the `real world' (system) in our chosen `formal world,' hence it is also called a \emph{model}.

\begin{definition}[Model of a Language]\label{definition:model}
    A \emph{model} of a language $\mathbb P$ is any truth assignment $v\colon \mathbb P\to \{0,1\}$. The \emph{set of (all) models of a language $\mathbb P$} is denoted by $\M_\mathbb P$:
    $$
    \M_\mathbb P=\left\{v \mid v\colon \mathbb P\to \{0,1\}\right\}=\{0,1\}^\mathbb P
    $$
\end{definition}
Models will be denoted by letters $v,u,w$, etc. ($v$ from the word `valuation'). A model of a language is therefore a function, formally a set of pairs (input, output). For example, for the language $\mathbb P=\{p,q,r\}$ and the truth assignment where $p$ is true, $q$ false, and $r$ true, we have the model
$$
v = \{(p,1),(q,0),(r,1)\}.
$$
For simplicity, we will write it as $v = (1,0,1)$. For the language $\mathbb P = \{p,q,r\}$, we have $2^3 = 8$ models: 
$$
\M_\mathbb P = \{(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)\}
$$

\begin{remark}
Formally speaking, we identify the set $\{0,1\}^\mathbb P$ with the set $\{0,1\}^{|\mathbb P|}$ using the ordering $\iota$ of the language $\mathbb P$ (see Remark~\ref{remark:order-of-language}). Specifically, instead of the element $v = \{(p,1),(q,0),(r,1)\} \in \{0,1\}^\mathbb P$, we write $(1,0,1) = (v \circ \iota)(0,1,2) = (v(\iota(0)),v(\iota(1)),v(\iota(2))) \in \{0,1\}^{|\mathbb P|}$ (where we allow the functions $v,\iota$ to act `component-wise').\footnote{Alternatively, we could require (at least for countable languages) that the language \emph{be} $\mathbb P = \{0,1,2,\dots\}$ and use symbols $p_0,p_1,p,q,r$ only for readability.} If this seems confusing, imagine the model $v$ as a set of atomic propositions that are true, i.e., $\{p,r\} \subseteq \mathbb P$, our notation $v = (1,0,1)$ is then the characteristic vector of this set. This identification will be used henceforth without further notice. 
\end{remark}


\subsection{Validity}

We are now ready to define the key concept of logic, \emph{validity} of a proposition in a given model. Informally, a proposition is valid in a model (i.e., under a specific truth assignment of atomic propositions) if its truth value, as calculated in Example~\ref{example:truth-value}, equals 1. In the formal definition, we will use the truth function of the proposition (Definition~\ref{definition:truth-function}).\footnote{For \emph{validity}, we use the symbol $\models$, which we read as `satisfies' or `models', in {\LaTeX} as {\textbackslash}models.}

\begin{definition}[Validity of a Proposition in a Model, Model of a Proposition]\label{definition:validity}
    Given a proposition $\varphi$ in a language $\mathbb P$ and a model $v \in \M_\mathbb P$, if $f_{\varphi,\mathbb P}(v) = 1$, we say that the proposition $\varphi$ is \emph{valid} in the model~$v$, $v$ is a \emph{model} of~$\varphi$, and we write $v \models \varphi$. The set of all models of the proposition $\varphi$ is denoted by $\M_\mathbb P(\varphi)$.
\end{definition}
Models of a language that are not models of $\varphi$ will sometimes be called \emph{non-models} of $\varphi$. They form the complement of the set of models of $\varphi$. Using the standard notation for function inverse, we can write:
\begin{align*}
    \M_\mathbb P(\varphi) &= \{v \in \M_\mathbb P \mid v \models \varphi\} = f_{\varphi,\mathbb P}^{-1}[1]\\
    \overline{\M_\mathbb P(\varphi)} = \M_\mathbb P \setminus \M_\mathbb P(\varphi) &= \{v \in \M_\mathbb P \mid v \not\models \varphi\} = f_{\varphi,\mathbb P}^{-1}[0]
\end{align*}

If the language is clear from the context, we can simply write $\M(\varphi)$. We must be really sure, though: for example, in the language $\mathbb P = \{p,q\}$ we have 
$$
\M_{\{p,q\}}(p \limplies q) = \{(0,0),(0,1),(1,1)\},
$$
while in the language $\mathbb P' = \{p,q,r\}$ we would have
$$
\M_{\mathbb P'}(p \limplies q) = \{(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,1,0),(1,1,1)\}.
$$

\begin{definition}[Validity of a Theory, Model of a Theory]\label{definition:validity-of-theory}
    Let $T$ be a theory in a language $\mathbb P$. The theory $T$ is \emph{valid} in a model $v$ if every axiom $\varphi \in T$ is valid in $v$. In this case, we also say that $v$ is a \emph{model} of $T$, and we write $v \models T$. The set of all models of the theory $T$ in a language $\mathbb P$ is denoted by $\M_\mathbb P(T)$.    
\end{definition}

When dealing with a finite theory, or adding a finite number of new axioms to a theory, we will use the following simplified notation:
\begin{itemize}
    \item $\M_\mathbb P(\varphi_1, \varphi_2, \dots, \varphi_n)$ instead of $\M_\mathbb P(\{\varphi_1, \varphi_2, \dots, \varphi_n\})$,
    \item $\M_\mathbb P(T, \varphi)$ instead of $\M_\mathbb P(T \cup \{\varphi\})$.
\end{itemize}

Note that $\M_\mathbb P(T, \varphi) = \M_\mathbb P(T) \cap \M_\mathbb P(\varphi)$, $\M_\mathbb P(T) = \bigcap_{\varphi \in T} \M_\mathbb P(\varphi)$, and for a finite theory (similarly for countable theories), we have
$$
\M_\mathbb P(\varphi_1)\supseteq \M_\mathbb P(\varphi_1,\varphi_2)\supseteq \M_\mathbb P(\varphi_1,\varphi_2,\varphi_3)\supseteq\dots\supseteq\M_\mathbb P(\varphi_1,\varphi_2,\dots,\varphi_n).
$$
We can use this when finding models by brute force.

\begin{example}
    We can find models of the theory $T = \{p \lor q \lor r, q \limplies r, \neg r\}$ (in the language $\mathbb P = \{p, q, r\}$) as follows. First, we find the models of the proposition $\neg r$:
    $$
    \M_\mathbb P(r) = \{(x, y, 0) \mid x, y \in \{0,1\}\} = \{(0,0,0),(0,1,0),(1,0,0),(1,1,0)\},
    $$
    then we determine in which of these models the proposition $q \limplies r$ is valid: 
    \begin{itemize}
        \item $(0,0,0) \models q \limplies r$,
        \item $(0,1,0) \not\models q \limplies r$,
        \item $(1,0,0) \models q \limplies r$,
        \item $(1,1,0) \not\models q \limplies r$,
    \end{itemize}  
    Thus $\M_\mathbb P(r, q \limplies r) = \{(0,0,0),(1,0,0)\}$. The proposition $p \lor q \lor r$ is valid only in the second of these models, so we get
    $$
    \M_\mathbb P(r, q \limplies r, p \lor q \lor r) = \M_\mathbb P(T) = \{(1,0,0)\}.
    $$
    This procedure is more efficient than determining the sets of models of the individual axioms and taking their intersection. (But much less efficient than using a formal proof system, such as the tableau method, which we will see later.)
\end{example}


\subsection{Additional semantic notions}

Following the notion of validity, we will use several other notions. For some properties, several different names are in use, depending on the context in which the property is discussed.

\begin{definition}[Semantic notions]\label{definition:semantic-notions}
We say that a proposition $\varphi$ (in a language $\mathbb P$) is
\begin{itemize}
    \item \emph{true}, \emph{tautology}, \emph{valid (in logic/logically)}, and we write $\models \varphi$, if it is valid in every model (of the language $\mathbb P$), $\M_\mathbb P(\varphi) = \M_\mathbb P$,
    \item \emph{false}, \emph{contradictory}, if it has no model, $\M_\mathbb P(\varphi) = \emptyset$,\footnote{Note that being \emph{false} is not the same as not being \emph{true}!}
    \item \emph{independent}, if it is valid in some model, and it is not valid in some other model, i.e., it is neither true nor false, $\emptyset \subsetneq \M_\mathbb P(\varphi) \subsetneq \M_\mathbb P$,
    \item \emph{satisfiable}, if it has some model, i.e., it is not false, $\M_\mathbb P(\varphi) \neq \emptyset$.
\end{itemize}
Furthermore, we say that propositions $\varphi, \psi$ (in the same language $\mathbb P$) are \emph{(logically) equivalent}, we write $\varphi \sim \psi$, if they have the same models, i.e.,
$$
\varphi \sim \psi \text{ if and only if } \M_\mathbb P(\varphi) = \M_\mathbb P(\psi).
$$    
\end{definition}

\begin{example} For example, the following hold:
    \begin{itemize}
        \item propositions $\top$, $p \lor q \liff q \lor p$ are true,
        \item propositions $\bot$, $(p \lor q) \land (p \lor \neg q) \land \neg p$ are false,
        \item propositions $p, p \land q$ are independent, and also satisfiable, and
        \item the following propositions are equivalent: 
        \begin{itemize}
            \item $p \sim p \lor p \sim p \lor p \lor p$,
            \item $p \limplies q \sim \neg p \lor q$,
            \item $\neg p \limplies (p \limplies q) \sim \top $.
        \end{itemize}  
    \end{itemize}      
\end{example}

The notions from Definition \ref{definition:semantic-notions} can also be relativized with respect to a given theory. This means that we restrict the individual definitions to the models of this theory:

\begin{definition}[Semantic Notions Relative to a Theory]
    Let $T$ be a theory in a language $\mathbb P$. We say that a proposition $\varphi$ in the language $\mathbb P$ is
    \begin{itemize}
        \item \emph{true in $T$}, a \emph{consequence of $T$}, \emph{valid in $T$}, and we write $T \models \varphi$, if $\varphi$ is valid in every model of the theory $T$, i.e., $\M_\mathbb P(T) \subseteq \M_\mathbb P(\varphi)$,
        \item \emph{false in $T$}, \emph{contradictory in $T$}, if it is not valid in any model of $T$, i.e., $\M_\mathbb P(\varphi) \cap \M_\mathbb P(T) = \M_\mathbb P(T,\varphi) = \emptyset$.
        \item \emph{independent in $T$}, if it is valid in some model of $T$, and not valid in some other model of $T$, i.e., it is neither true in $T$ nor false in $T$, $\emptyset \subsetneq \M_\mathbb P(T,\varphi) \subsetneq \M_\mathbb P(T)$,
        \item \emph{satisfiable in $T$}, \emph{consistent with $T$}, if it is valid in some model of $T$, i.e., it is not false in $T$, $\M_\mathbb P(T,\varphi) \neq \emptyset$.
    \end{itemize}
    And we say that propositions $\varphi, \psi$ (in the same language $\mathbb P$) are \emph{equivalent in $T$}, \emph{$T$-equivalent}, we write $\varphi \sim_T \psi$ if they hold in the same models of $T$, i.e.,
    $$
    \varphi \sim_T \psi \text{ if and only if } \M_\mathbb P(T,\varphi) = \M_\mathbb P(T,\psi).
    $$
\end{definition}

Note that for the empty theory $T = \emptyset$, we have $\M_\mathbb P(T) = \M_\mathbb P$ and the above concepts for $T$ coincide with the original ones. Again, we illustrate the concepts with several examples:

\begin{example} Let $T = \{p \lor q, \neg r\}$. The following hold:
    \begin{itemize}
        \item propositions $q \lor p$, $\neg p \lor \neg q \lor \neg r$ are true in $T$,
        \item the proposition $(\neg p \land \neg q) \lor r$ is false in $T$,
        \item propositions $p \liff q, p \land q$ are independent in $T$, and also satisfiable, and
        \item $p$ and $p\lor r$ are $T$-equivalent, $p \sim_T p \lor r$ (but $p \not\sim p \lor r$).
    \end{itemize}      
\end{example}


\subsection{Universality of Logical Connectives}

In the language of propositional logic, we use the following logical connectives: $\neg, \land, \lor, \limplies, \liff$. This is not the only possible choice; to build a fully-fledged logic, we could make do, for example, only with negation and implication,\footnote{Negation is needed to describe the state of a system, and implication to describe behavior over time.} or negation, conjunction, and disjunction.\footnote{These are sufficient to build logical circuits.} And as we will see below, we could use other logical connectives as well. Our choice is the golden middle path between expressiveness on the one hand and succinctness of syntactic definitions and proofs on the other.

What do we mean by saying that logic is fully-fledged? We say that a set of logical connectives $S$ is \emph{universal}\footnote{Some people would say \emph{[functionally] complete}.} if any Boolean function $f$ can be expressed as the truth function $f_{\varphi,\mathbb P}$ of some proposition $\varphi$ built from the logical connectives in $S$ (where $|\mathbb P|=n$ if $f$ is an $n$-ary function). Equivalently, for any finite language $\mathbb P$ (say $n$-element) and any set of models $M \subseteq \M_\mathbb P$, there must exist a proposition $\varphi$ such that $\M_\mathbb P(\varphi) = M$. (The equivalence of these two statements follows from the fact that if we have a Boolean function $f$ and choose $M = f^{-1}[1]$, then $f_{\varphi,\mathbb P} = f$ if and only if $\M_\mathbb P(\varphi) = M$.)

\begin{proposition} \label{proposition:not-and-or-is-universal}
    The sets of logical connectives $\{\neg, \land, \lor\}$ and $\{\neg, \limplies\}$ are universal.
\end{proposition}

\begin{proof}
Let us have a function $f\colon \{0,1\}^n\to \{0,1\}$, or equivalently a set of models $M = f^{-1}[1] \subseteq \{0,1\}^n$. Our language will be $\mathbb P = \{p_1, \dots, p_n\}$. If the set $M$ contained only one model, say $v = (1,0,1,0)$, we could represent it with the proposition $\varphi_v = p_1 \land \neg p_2 \land p_3 \land \neg p_4$, which says `I must be the model $v$.' For a general model $v$, we would write the proposition $\varphi_v$ as follows:
$$
\varphi_v = p_1^{v_1} \land p_2^{v_2} \land \dots \land p_n^{v_n} = \bigwedge_{i=1}^n p_i^{v(p_i)} = \bigwedge_{p \in \mathbb P} p^{v(p)},
$$
where we introduce the following useful notation: $p^{v(p)}$ is the proposition $p$ if $v(p) = 1$, and the proposition $\neg p$ if $v(p) = 0$.

If the set $M$ contains more models, we say `I must be at least one of the models from $M$':
$$
\varphi_M = \bigvee_{v \in M} \varphi_v = \bigvee_{v \in M} \bigwedge_{p \in \mathbb P} p^{v(p)}
$$
Clearly, $\M_\mathbb P(\varphi_M) = M$, or equivalently $f_{\varphi_M,\mathbb P} = f$. (If $M = \emptyset$, then by definition $\bigvee_{v \in M} \varphi_v = \bot$.)\footnote{Similar to how the sum of an empty set of summands equals 0.}

The universality of $\{\neg, \limplies\}$ follows from the universality of $\{\neg, \land, \lor\}$ and the fact that conjunction and disjunction can be expressed using negation and implication: $p \land q \sim \neg (p \limplies \neg q)$ and $p \lor q \sim \neg p \limplies q$.
\end{proof}

\begin{remark}
Note that in the construction of the proposition $\varphi_M$, it is crucial that the set $M$ is finite (it has at most $2^n$ elements). If it were infinite, the symbol `$\bigvee_{v \in M}$' would mean `disjunction' of infinitely many propositions, and thus the result would not be a finite string, i.e., `$\varphi_M$' would not be a proposition. (If we have a countably infinite language $\mathbb P'$, then not every subset $M \subseteq \M_{\mathbb P'}$ can be represented by a proposition---there are uncountably many such subsets, while propositions are only countably many.)
\end{remark}

What other logical connectives could we use? Nullary Boolean functions,\footnote{In formalizing mathematics or computer science, a function of arity 0 means it has no inputs, so the output cannot depend on the input and is constant. Formally, these are functions $f\colon \emptyset\to \{0,1\}$. If this is confusing, assume that functions must have an arity of at least 1, and instead of `nullary function', say `constant.'} i.e. constants 0, 1, could be introduced as symbols TRUE and FALSE; we will suffice with propositions $\top, \bot$. There are four unary Boolean functions ($4 = 2^{2^1}$), but negation is the only `interesting' one: the others are $f(x) = x$, $f(x) = 0$, and $f(x) = 1$. There are more interesting binary logical connectives that occur naturally, for example:
\begin{itemize}
    \item NAND or \emph{Sheffer's stroke}, sometimes denoted as $p \uparrow q$, where $p \uparrow q \sim \neg (p \land q)$,
    \item NOR or \emph{Peirce's arrow}, sometimes denoted as $p \downarrow q$, where $p \downarrow q \sim \neg (p \lor q)$,
    \item XOR, or \emph{exclusive-OR}, sometimes denoted as $\oplus$, where $p \oplus q \sim (p \lor q) \land \neg (p \land q)$, i.e. the sum of truth values modulo 2.
\end{itemize}

\begin{exercise}
    Express $(p \oplus q) \oplus r$ using $\{\neg, \land, \lor\}$.
\end{exercise}

\begin{exercise}
    Show that $\{\mathrm{NAND}\}$ and $\{\mathrm{NOR}\}$ are universal.
\end{exercise}

\begin{exercise}
Consider the ternary logical connective $\mathrm{IFTE}$, where $IFTE(p,q,r)$ is satisfied if and only if `if $p$ then $q$ else $r$'. Determine the truth table of this logical connective (i.e., the function $f_\mathrm{IFTE}$) and show that $\{\mathrm{TRUE}, \mathrm{FALSE}, \mathrm{IFTE}\}$ is universal.
\end{exercise}


\section{Normal Forms}

Let us recall that propositions are equivalent if they have the same set of models. For each proposition, there exist infinitely many equivalent propositions; it is often useful to express a proposition in a `nice' (useful) `shape', i.e., to find an equivalent proposition of that `shape'. This concept of `shape' in mathematics is called a \emph{normal form}. We will introduce two most common normal forms: \emph{conjunctive normal form (CNF)} and \emph{disjunctive normal form (DNF)}.

The following terminology and notation are needed:
\begin{itemize}
    \item A \emph{literal} $\ell$ is either a propositional variable $p$ or the negation of a propositional variable $\neg p$. For a propositional variable $p$, denote $p^0=\neg p$ and $p^1=p$. If $\ell$ is a literal, then $\bar{\ell}$ denotes the \emph{opposite literal} to $\ell$. If $\ell=p$ (a \emph{positive literal}), then $\bar{\ell}=\neg p$; if $\ell=\neg p$ (a \emph{negative literal}), then $\bar{\ell}=p$.
    \item A \emph{clause} is a disjunction of literals $C=\ell_1 \lor \ell_2 \lor \dots \lor \ell_n$. A \emph{unit clause} is a single literal ($n=1$) and the \emph{empty clause} ($n=0$) is interpreted as $\bot$.
    \item A proposition is in \emph{conjunctive normal form (CNF)} if it is a conjunction of clauses. The \emph{empty CNF proposition} is $\top$.
    \item An \emph{elementary conjunction} is a conjunction of literals $E=\ell_1 \land \ell_2 \land \dots \land \ell_n$. A \emph{unit elementary conjunction} is a single literal ($n=1$). The \emph{empty elementary conjunction} ($n=0$) is $\top$.
    \item A proposition is in \emph{disjunctive normal form (DNF)} if it is a disjunction of elementary conjunctions. The \emph{empty DNF proposition} is $\bot$.
\end{itemize}

\begin{example}
    The proposition ${{p\lor q}\lor\neg r}$ is in CNF (it is a single clause) as well as in DNF (it is a disjunction of unit elementary conjunctions). The proposition $(p\lor q)\land (p\lor \neg q)\land \neg p$ is in CNF, while the proposition $\neg p\lor (p\land q)$ is in DNF.
\end{example}

\begin{example}
    The proposition $\varphi_v$ from the proof of Proposition~\ref{proposition:not-and-or-is-universal} is in CNF (it is a conjunction of unit clauses, i.e., literals) and also in DNF (it is a single elementary conjunction). The proposition $\varphi_M$ is in DNF.
\end{example}

\begin{observation}
    Note that a proposition in CNF is a tautology if and only if each of its clauses contains a pair of opposite literals. Similarly, a proposition in DNF is satisfiable if and only if not every elementary conjunction contains a pair of opposite literals.
\end{observation}


\subsection{On Duality}

Note that if we interchange the values for truth and falsehood in propositional logic, i.e., 0 and 1, the truth table for negation remains the same, while conjunction becomes disjunction, and vice versa. This concept is called \emph{duality}; we will see many examples of this in logic.

We have $\neg(p \land q) \sim (\neg p \lor \neg q)$, and from \emph{duality}, we also know that $\neg(\neg p \lor \neg q) \sim (\neg \neg p \land \neg \neg q)$, from which we can easily deduce $\neg(p \lor q) \sim (\neg p \land \neg q)$.\footnote{Since $p,q$ are propositional variables, they can be assigned both values 0 and 1, thus we can interchange them with their opposite literals.} More generally, $n$-ary Boolean functions $f, g$ are \emph{dual} to each other if $f(\neg x) = \neg g(x)$. If we have a proposition $\varphi$ built from $\{\neg, \land, \lor\}$ and we interchange $\land$ and $\lor$, and negate the propositional variables (i.e., interchange literals with their opposite literals), we obtain a proposition $\psi \sim \neg \varphi$ (i.e., the models of $\varphi$ are the non-models of $\psi$ and vice versa), and the functions $f_{\varphi, \mathbb P}$ and $f_{\psi, \mathbb P}$ are dual to each other.

The notion of DNF is dual to the notion of CNF; `is a tautology' is dual to `is not satisfiable', thus the previous observation can be understood as an example of duality. For every statement in propositional logic, we obtain a \emph{dual} statement `for free', resulting from the interchange of $\land$ and $\lor$, truth and falsehood.


\subsection{Conversion to Normal Forms}\label{subsection:convert-to-normal-form}

We have already encountered the disjunctive normal form in the proof of Proposition~\ref{proposition:not-and-or-is-universal}. The key part of the proof can be formulated as follows: `If the language is finite, any set of models can be \emph{axiomatized} by a proposition in DNF'. From duality, we also obtain axiomatization in CNF since the complement of a set of models is also a set of models:

\begin{proposition} \label{proposition:axiomatize-in-DNF-CNF}
    Given a finite language $\mathbb P$ and any set of models $M \subseteq \M_\mathbb P$, there exists a proposition $\varphi_{\mathrm{DNF}}$ in DNF and a proposition $\varphi_{\mathrm{CNF}}$ in CNF such that $M = \M_\mathbb P(\varphi_{\mathrm{DNF}}) = \M_\mathbb P(\varphi_{\mathrm{CNF}})$. Specifically:
\begin{align*}
    \varphi_{\mathrm{\mathrm{DNF}}} &= \bigvee_{v \in M} \bigwedge_{p \in \mathbb P} p^{v(p)} \\
    \varphi_{\mathrm{CNF}} &= \bigwedge_{v \in \overline{M}} \bigvee_{p \in \mathbb P} \overline{p^{v(p)}} = \bigwedge_{v \notin M} \bigvee_{p \in \mathbb P} p^{1-v(p)}
\end{align*}
\end{proposition}

\begin{proof}
    For the proposition $\varphi_{\mathrm{DNF}}$, see the proof of Proposition~\ref{proposition:not-and-or-is-universal}, where each elementary conjunction describes one model. The proposition $\varphi_{\mathrm{CNF}}$ is dual to the proposition $\varphi'_{\mathrm{DNF}}$ constructed for the complement $M' = \overline{M}$. Alternatively, we can prove it directly: the models of the clause $C_v = \bigvee_{p \in \mathbb P} p^{1-v(p)}$ are all models except $v$, $\M_C = \M_\mathbb P \setminus \{v\}$, so each clause in the conjunction excludes one non-model.
\end{proof}

Proposition~\ref{proposition:axiomatize-in-DNF-CNF} provides a method for converting a proposition to disjunctive or conjunctive normal form:

\begin{example}
    Consider the proposition $\varphi = p \liff (q \lor \neg r)$. First, we find the set of models: $M = \M(\varphi) = \{(0,0,1),(1,0,0),(1,1,0),(1,1,1)\}$. Then, we find the propositions $\varphi_{\mathrm{DNF}}$ and $\varphi_{\mathrm{CNF}}$ according to Proposition \ref{proposition:axiomatize-in-DNF-CNF}. Those have the same models as $\varphi$ and are therefore equivalent with it.

    We find the proposition $\varphi_{\mathrm{DNF}}$ by constructing an elementary conjunction for each model that enforces precisely that model:
    $$
    \varphi_{\mathrm{DNF}} = (\neg p \land \neg q \land r) \lor (p \land \neg q \land \neg r) \lor (p \land q \land \neg r) \lor (p \land q \land r)
    $$
    For constructing $\varphi_{\mathrm{CNF}}$, we need the \emph{non-models} of $\varphi$, $\overline{M} = \{(0,0,0),(0,1,0),(0,1,1),(1,0,1)\}$. Each clause excludes one non-model:
    $$
    \varphi_{\mathrm{CNF}} = (p \lor q \lor r) \land (p \lor \neg q \lor r) \land (p \lor \neg q \lor \neg r) \land (\neg p \lor q \lor \neg r)
    $$   
\end{example}

\begin{corollary}
    Every proposition (in any, even infinite, language $\mathbb P$) is equivalent to some proposition in CNF and some proposition in DNF.
\end{corollary}
\begin{proof}
Even if the language $\mathbb P$ is infinite, the proposition $\varphi$ contains only finitely many propositional variables, so we can use Proposition \ref{proposition:axiomatize-in-DNF-CNF} for the language $\mathbb P' = \Var(\varphi)$ and the set of models $M = \M_{\mathbb P'}(\varphi)$. Since $M = \M_{\mathbb P'}(\varphi_{\mathrm{DNF}}) = \M_{\mathbb P'}(\varphi_{\mathrm{CNF}})$, we have $\varphi \sim \varphi_{\mathrm{DNF}} \sim \varphi_{\mathrm{CNF}}$.
\end{proof}

\begin{exercise}
Describe how one can easily generate models from a DNF proposition and non-models from a CNF proposition.
\end{exercise}

\begin{remark}
    When can a \emph{theory} be axiomatized by a proposition in DNF or CNF? Consider the language $\mathbb P' = \Var(T)$ (i.e., all propositional variables occurring in the axioms of $T$). If $T$ in the language $\mathbb P'$ has finitely many models (i.e., $\M_{\mathbb P'}(T)$ is finite), we can construct a proposition in DNF, and if it has finitely many \emph{non-models}, we can construct a proposition in CNF. Generally, however, not every theory can be axiomatized by a \emph{single} proposition in CNF or DNF. We can always convert individual axioms to CNF (or DNF), and we can also axiomatize the theory using (potentially infinitely many) clauses.
\end{remark}

This method of conversion to CNF or DNF requires knowledge of the set of models of the proposition, so it is quite inefficient. Additionally, the resulting normal form can be very long. We will now show another method.

\subsubsection{Conversion Using Equivalent Transformations}

We use the following observation: If we replace some subproposition $\psi$ of a proposition $\varphi$ with an equivalent proposition $\psi'$, the resulting proposition $\varphi'$ will also be equivalent to $\varphi$. We will first demonstrate the method on an example:

\begin{example}
    Again, we will convert the proposition $\varphi = p \liff (q \lor \neg r)$. First, we eliminate the equivalence, expressing it as a conjunction of two implications. In the next step, we remove the implications using the rule $\varphi \limplies \psi \sim \neg \varphi \lor \psi$:
    \begin{align*}
        p \liff (q \lor \neg r) &\sim (p \limplies (q \lor \neg r)) \land ((q \lor \neg r) \limplies p)\\
        &\sim (\neg p \lor q \lor \neg r) \land (\neg (q \lor \neg r) \lor p)
    \end{align*}
    Now, imagine the tree of the proposition; in the next step, we want to push the negations as low as possible in the tree, just above the leaves: we use $\neg (q \lor \neg r) \sim \neg q \land \neg \neg r$ and eliminate the double negation $\neg \neg r \sim r$. We obtain the proposition
    $$
    (\neg p \lor q \lor \neg r) \land ( (\neg q \land r) \lor p)
    $$
    At this point, we leave the literals untouched and apply the distributivity of $\landsymb$ over $\lorsymb$, or vice versa, depending on whether we want DNF or CNF. For conversion to CNF, we use the transformation $(\neg q \land r) \lor p \sim (\neg q \lor p) \land (r \lor p)$, which pushes the $\lorsymb$ symbol lower in the tree. (Draw the tree!) This gives us a proposition in CNF; for better readability, we sort the literals in the clauses:
    $$
    (\neg p \lor q \lor \neg r) \land (p \lor \neg q) \land (p \lor r)
    $$
    For conversion to DNF, we proceed similarly by repeatedly applying distributivity. Here, we start from the CNF form and combine each literal from the first clause with each literal from the second and each literal from the third clause. Note that the same literal does not need to be repeated twice in the elementary conjunction, and if the elementary conjunction contains a pair of opposite literals, it is contradictory and can be omitted in the DNF. We can also omit an elementary conjunction $E$ if we have another elementary conjunction $E'$ such that  the literals contained in $E'$ are a subset of the literals contained in $E$, e.g., $E = (p \land q \land \neg r)$ and $E' = (p \land \neg r)$. (Think about why, and formulate the dual simplification when converting to CNF.) The resulting proposition in DNF is:
    $$
    (\neg p \land \neg q \land r) \lor (p \land q \land r) \lor (p \land \neg r)
    $$
\end{example}

We now list all equivalent transformations needed for the method. The proof that every proposition can be converted to DNF and CNF can be easily carried out by induction on the structure of the proposition (depth of the proposition tree).

\begin{tcolorbox}
\begin{multicols}{2}
\begin{itemize}
    \item Implications and equivalences:
    \begin{itemize}
        \item[] $\varphi \limplies \psi \sim \neg \varphi \lor \psi$
        \item[] $\varphi \liff \psi \sim (\neg \varphi \lor \psi) \land (\neg \psi \lor \varphi)$
    \end{itemize}
    \item Negations:
    \begin{itemize}
        \item[] $\neg (\varphi \land \psi) \sim \neg \varphi \lor \neg \psi$
        \item[] $\neg (\varphi \lor \psi) \sim \neg \varphi \land \neg \psi$
        \item[] $\neg \neg \varphi \sim \varphi$
    \end{itemize}
    \item Conjunctions (conversion to DNF):
    \begin{itemize}
        \item[] $\varphi \land (\psi \lor \chi) \sim (\varphi \land \psi) \lor (\varphi \land \chi)$
        \item[] $(\varphi \lor \psi) \land \chi \sim (\varphi \land \chi) \lor (\psi \land \chi)$
    \end{itemize}
    \item Disjunctions (conversion to CNF):
    \begin{itemize}
        \item[] $\varphi \lor (\psi \land \chi) \sim (\varphi \lor \psi) \land (\varphi \lor \chi)$
        \item[] $(\varphi \land \psi) \lor \chi \sim (\varphi \lor \chi) \land (\psi \lor \chi)$
    \end{itemize}
\end{itemize}
\end{multicols}
\end{tcolorbox}

As we will see in the next chapter, CNF is much more important in practice than DNF (even though they are dual concepts). For describing a real system, it is more natural to express it as a conjunction of many simpler properties than as a single very long disjunction. There are many other forms of representing Boolean functions. Similar to data structures, we choose the appropriate form of representation depending on the operations we need to perform on the function.\footnote{See, for example, the course \href{https://is.cuni.cz/studium/predmety/index.php?do=predmet&kod=NAIL031}{NAIL031 Representations of Boolean Functions}.}


\section{Properties and Consequences of Theories}

Let us delve deeper into properties of theories. Similar to propositions, we say that two theories $T, T'$ in the language $\mathbb P$ are \emph{equivalent} if they have the same set of models:
$$
T \sim T' \text{ if and only if } \M_\mathbb P(T) = \M_\mathbb P(T')
$$
These are theories expressing the same properties of models, just formulated (\emph{axiomatized}) differently. In logic, we are mainly interested in properties of theories that are independent of the specific \emph{axiomatization}.

\begin{example}
    For example, the theory $T = \{p \limplies q, p \liff r\}$ is equivalent to the theory $T' = \{(\neg p \lor q) \land (\neg p \lor r) \land (p \lor \neg r)\}$.
\end{example}

\begin{definition}[Properties of Theories]
We say that a theory $T$ in the language $\mathbb P$ is
\begin{itemize}
    \item \emph{inconsistent} (\emph{unsatisfiable}), if it includes $\bot$ (a contradiction), equivalently, if it has no model, equivalently, if it includes all propositions,
    \item \emph{consistent} (\emph{satisfiable}) if it is not inconsistent, i.e., it has some model,
    \item \emph{complete} if it is not inconsistent and every proposition in it is either true or false (i.e., it has no independent propositions), equivalently, if it has exactly one model.
\end{itemize}    
\end{definition}

Let us verify that the equivalence of properties in the definition holds. Notice that in an inconsistent theory, all propositions are indeed valid! A proposition is valid in $T$ if it is valid in every model of $T$, but there are none. Conversely, if the theory has at least one model, $\bot = p \land \neg p$ cannot be valid in this model.

If a theory is complete, it cannot have two different models $v \neq v'$. The proposition $\varphi_{v} = \bigwedge_{p \in \mathbb P} p^{v(p)}$ (which we encountered in the proof of Proposition \ref{proposition:not-and-or-is-universal}) would be independent in $T$ because it is valid in the model $v$ but not in $v'$. Conversely, if $T$ has a single model $v$, then every proposition is either valid in $v$ and thus in $T$, or it is not valid in $v$ and therefore false in $T$.

\begin{example} 
    An example of an inconsistent theory is $T_1 = \{p, p \limplies q, \neg q\}$. The theory $T_2 = \{p \lor q, r\}$ is consistent but not complete, for instance, the proposition $p \land q$ is neither true (it does not hold in the model $(1,0,1)$) nor false (it holds in the model $(1,1,1)$). The theory $T_2 \cup \{\neg p\}$ is complete, with its only model being $(0,1,1)$.
\end{example}


\subsection{Consequences of Theories}

Recall that a consequence of a theory $T$ is any proposition that is true in $T$ (i.e., valid in every model of $T$), and let us denote the \emph{set of all consequences} of a theory $T$ in the language $\mathbb P$ as
$$
\Conseq_\mathbb P(T) = \{\varphi \in \VF_\mathbb P \mid T \models \varphi\}
$$
If the theory $T$ is in the language $\mathbb P$, we can write:
$$
\Conseq_\mathbb P(T) = \{\varphi \in \VF_\mathbb P \mid \M_\mathbb P(T) \subseteq \M_\mathbb P(\varphi)\}
$$
(However, it is also meaningful to talk about consequences of a theory that are in some smaller language, which is a subset of the language of $T$).

Let us demonstrate some simple properties of consequences:
\begin{proposition}\label{proposition:properties-of-consequences}
    Let $T, T'$ be theories and $\varphi, \varphi_1, \dots, \varphi_n$ be propositions in a language $\mathbb P$. Then the following holds:
    \begin{enumerate}[(i)]       
        \item $T \subseteq \Conseq_\mathbb P(T)$,
        \item $\Conseq_\mathbb P(T) = \Conseq_\mathbb P(\Conseq_\mathbb P(T))$,
        \item if $T \subseteq T'$, then $\Conseq_\mathbb P(T) \subseteq \Conseq_\mathbb P(T')$,
        \item $\varphi \in \Conseq_\mathbb P(\{\varphi_1, \dots, \varphi_n\})$ if and only if the proposition $(\varphi_1 \land \dots \land \varphi_n) \to \varphi$ is a tautology.
    \end{enumerate}
\end{proposition}

\begin{proof}
    The proof is straightforward, using the fact that $\varphi$ is a consequence of $T$ if and only if $\M_\mathbb P(T) \subseteq \M_\mathbb P(\varphi)$, and recognizing the following relationships:
    \begin{itemize}
        \item $\M(\Conseq(T)) = \M(T)$,
        \item if $T \subseteq T'$, then $\M(T) \supseteq \M(T')$,\footnote{The more properties we prescribe, the fewer objects will satisfy them all.}
        \item $\psi \limplies \varphi$ is a tautology if and only if $\M(\psi) \subseteq \M(\varphi)$,
        \item $\M(\varphi_1 \land \dots \land \varphi_n) = \M(\varphi_1, \dots, \varphi_n)$.
    \end{itemize}
\end{proof}

\begin{exercise}
    Give a detailed proof of Proposition~\ref{proposition:properties-of-consequences}.
\end{exercise}


\subsection{Extensions of Theories}

Informally speaking, an \emph{extension} of a theory $T$ refers to any theory $T'$ that satisfies everything that is true in $T$ (and more, apart from the trivial case). If theory $T$ models some system, it can be extended in two ways: by adding additional requirements about the system (which we will call a \emph{simple extension}) or by expanding the system with some new parts. If in the second case there are no additional requirements on the original part of the system, i.e., exactly the same hold about the original part as before, we say that the extension is \emph{conservative}.

\begin{example}
    Let us return to the initial example of graph coloring, Example \ref{example:graph-coloring-intro}. The theory $T_3$ (complete colorings satisfying the edge condition) is a simple extension of the theory $T_1$ (partial colorings of vertices with no regard for edges). The theory $T_3'$ from Section \ref{subsection:disadvantages-of-propositional-logic} (adding a new vertex to the graph) is a conservative, non-simple extension of $T_3$. And it is an extension of $T_1$ that is neither simple nor conservative.
\end{example}

Let us now finally present the formal definitions:

\begin{definition}[Extension of a Theory]
    Let $T$ be a theory in the language $\mathbb P$.
    \begin{itemize}
        \item An \emph{extension} of the theory $T$ is any theory $T'$ in a language $\mathbb P' \supseteq \mathbb P$ that satisfies $\Conseq_\mathbb P(T) \subseteq \Conseq_{\mathbb P'}(T')$,
        \item it is a \emph{simple extension} if $\mathbb P' = \mathbb P$,
        \item it is a \emph{conservative extension} if $\Conseq_\mathbb P(T) = \Conseq_\mathbb P(T') = \Conseq_{\mathbb P'}(T') \cap \VF_\mathbb P$.
    \end{itemize}
\end{definition}
Thus, an extension means that it satisfies all the consequences of the original theory. An extension is simple if we do not add any new propositional variables to the language, and it is conservative if it does not change the validity of statements expressible in the original language, meaning that any new consequence must contain some of the newly added propositional variables.

What do these concepts mean \emph{semantically}, in terms of models? Let us first formulate a general observation, which we will then illustrate with an example:
\begin{observation}\label{observation:extensions-semantic-description-propositional}
    Let $T$ be a theory in the language $\mathbb P$, and $T'$ a theory in a language $\mathbb P'$ containing the language $\mathbb P$. Then the following holds:
    \begin{itemize}
        \item $T'$ is a simple extension of $T$ if and only if $\mathbb P' = \mathbb P$ and $\M_\mathbb P(T') \subseteq \M_\mathbb P(T)$,
        \item $T'$ is an extension of $T$ if and only if $\M_{\mathbb P'}(T') \subseteq \M_{\mathbb P'}(T)$. We thus consider models of theory $T$ in the extended language $\mathbb P'$.\footnote{Note that we cannot write $\M_\mathbb P(T')$ because models of $T'$ must be truth assignments of the larger language $\mathbb P'$, and values only for the propositional variables in $\mathbb P$ are not sufficient to determine the truth value of axioms of $T'$. And we cannot write $\M_{\mathbb P'}(T') \subseteq \M_{\mathbb P}(T)$ either, as these are sets of vectors of different dimensions.} In other words, the \emph{restriction}\footnote{\emph{Restriction} means forgetting the values for the new propositional variables, i.e., deleting the corresponding coordinates in the vector representation of the model.} of any model $v \in \M_{\mathbb P'}(T')$ to the original language $\mathbb P$ must be a model of $T$. We could write $v{\restriction_\mathbb P} \in \M_\mathbb P(T)$ or:
        $$
        \{v{\restriction_\mathbb P} \mid v \in \M_{\mathbb P'}(T')\} \subseteq \M_\mathbb P(T)
        $$
        \item $T'$ is a conservative extension of $T$ if it is an extension and, moreover, every model of $T$ (in the language $\mathbb P$) can be \emph{expanded}\footnote{By adding values for the new propositional variables, i.e., adding the corresponding coordinates in the vector representation.}  (in some way, not necessarily uniquely) to a model of $T'$ (in the language $\mathbb P'$), in other words, \emph{every} model of $T$ (in the language $\mathbb P$) is obtained by restricting \emph{some} model of $T'$ to the language $\mathbb P$. We could write:
        $$
        \{v{\restriction_\mathbb P} \mid v \in \M_{\mathbb P'}(T')\} = \M_\mathbb P(T)
        $$
        \item $T'$ is an extension of $T$ and $T$ is an extension of $T'$, if and only if $\mathbb P' = \mathbb P$ and $\M_\mathbb P(T') = \M_\mathbb P(T)$, in other words, $T' \sim T$.
        \item Complete simple extensions of $T$ correspond to models of $T$, uniquely up to equivalence.
    \end{itemize}
\end{observation}

\begin{example}
Consider the theory $T = \{p \limplies q\}$ in the language $\mathbb P = \{p, q\}$. The theory $T_1 = \{p \land q\}$ in the language $\mathbb P$ is a simple extension of $T$, we have $\M_\mathbb P(T_1) = \{(1, 1)\} \subseteq \{(0, 0), (0, 1), (1, 1)\} = \M_\mathbb P(T)$. It is a complete theory, and other complete simple extensions of theory $T$ are, for example, $T_2 = \{\neg p, q\}$ and $T_3 = \{\neg p, \neg q\}$. Each complete simple extension of theory $T$ is equivalent to $T_1$, $T_2$, or $T_3$.

Now consider the theory $T' = \{p \liff (q \land r)\}$ in the language $\mathbb P' = \{p, q, r\}$. It is an extension of $T$ because $\mathbb P = \{p, q\} \subseteq \{p, q, r\} = \mathbb P'$ and:
\begin{align*}
    \M_{\mathbb P'}(T') &= \{(0, 0, 0), (0, 0, 1), (0, 1, 0), (1, 1, 1)\}\\ 
    &\subseteq \{(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 1, 0), (1, 1, 1)\} = \M_{\mathbb P'}(T)     
\end{align*}
In other words, by restricting the models of $T'$ to the language $\mathbb P$, we get $\{(0, 0), (0, 1), (1, 1)\}$, which is a subset of $\M_\mathbb P(T)$.

Because $\{(0, 0), (0, 1), (1, 1)\} = \M_\mathbb P(T)$, in other words, every model $v \in \M_\mathbb P(T)$ can be expanded to a model $v' \in \M_{\mathbb P'}(T')$ (e.g., $(0, 1)$ can be expanded by defining $v'(r) = 0$ to the model $(0, 1, 0)$), $T'$ is even a conservative extension of $T$. This means that every proposition in the language $\mathbb P$ is valid in $T$ if and only if it is valid in $T'$. But the proposition $p \limplies r$ (which is in the language $\mathbb P'$, but not in the language $\mathbb P$) is a new consequence: it is valid in $T'$ but not in $T$ (see the model $(1, 1, 0)$).

The theory $T'' = \{\neg p \lor q, \neg q \lor r, \neg r \lor p\}$ in the language $\mathbb P'$ is an extension of $T$ but not a conservative extension because $p \liff q$ is valid in $T''$, but not in $T$. Or because the model $(0, 1)$ of the theory $T$ cannot be extended to a model of $T''$: neither $(0, 1, 0)$ nor $(0, 1, 1)$ satisfy the axioms of $T''$.

The theory $T$ is a (simple) extension of the theory $\{\neg p \lor q\}$ in the language $\mathbb P$, and vice versa: $T \sim \{\neg p \lor q\}$. It is also, like any theory, a simple conservative extension of itself.
\end{example}

\begin{exercise}
    Show (in detail) that if a theory $T$ has a complete conservative extension, then it must itself be complete.
\end{exercise}


\section{Algebra of Propositions}

In logic, we are usually\footnote{Unless, for example, we have a syntactic-transformation-based method such as conversion to CNF.} interested in propositions (or theories) \emph{up to equivalence}.\footnote{We can view them as a kind of abstract `properties' of models, regardless of their specific description.} The correct answer to the question `How many different propositions are there in the language $\mathbb{P} = \{p, q, r\}$?' is `Infinitely many'. However, we are probably interested in propositions \emph{up to equivalence} (in other words, \emph{mutually inequivalent}). There are as many of these as there are different subsets of models of the language, which is $2^{|\M_\mathbb{P}|} = 2^8 = 256$. Indeed, if two propositions have the same set of models, they are equivalent by definition. And for each set of models, we can find a corresponding proposition, e.g., in DNF (see \ref{proposition:axiomatize-in-DNF-CNF}). Let us consider slightly more complex reasoning:

\begin{example}
    Let $T$ be a theory in the language $\mathbb{P} = \{p, q, r\}$ having exactly five models. How many propositions over $\mathbb{P}$ (up to equivalence) are independent in the theory $T$? Let $|\mathbb{P}| = n = 3$ and $|\M_\mathbb{P}(T)| = k = 5$.

    We count the sets $M = \M_\mathbb{P}(\varphi)$ and require that $\emptyset \neq M \cap \M_\mathbb{P}(T) \neq \M_\mathbb{P}(T)$. Thus, we have a total of $2^k - 2 = 30$ possibilities for what the set $M \cap \M_\mathbb{P}(T)$ may be. And for each model of the language that is not a model of $T$ (there are $2^n - k = 3$ of these), we can choose arbitrarily whether or not it will be in $M$. Altogether, we get $(2^k - 2) \cdot 2^{2^n - k} = 30 \cdot 2^{8 - 5} = 240$ possible sets $M$. Hence that is the number of propositions independent in $T$, up to equivalence.
\end{example}

Let us explore the matter on a more abstract level. Formally, we consider the set of equivalence classes of $\sim$ on the set of all propositions $\VF_\mathbb{P}$, which we denote as $\sfrac{\VF_\mathbb{P}}{\sim}$. The elements of this set are sets of equivalent propositions, e.g., $[p \limplies q]_\sim = \{p \limplies q, \neg p \lor q, \neg(p \land \neg q), \neg p \lor q \lor q, \dots\}$. And we have a mapping $h:\sfrac{\VF_\mathbb{P}}{\sim} \to \mathcal{P}(\M_\mathbb{P})$ (where $\mathcal{P}(X)$ is the set of all subsets of $X$) defined by:
$$
h([\varphi]_\sim) = \M(\varphi)
$$
That is, to an equivalence class of propositions we assign the set of models of any member of that class. It is easy to verify that this mapping is well-defined (the definition does not depend on the choice of proposition from the class), injective, and if the language $\mathbb{P}$ is finite, then $h$ is even bijective. (Do verify this!)

On the set $\sfrac{\VF_\mathbb{P}}{\sim}$, we can define operations $\neg, \land, \lor$ by:
\begin{align*}
    \neg [\varphi]_\sim &= [\neg \varphi]_\sim \\
    [\varphi]_\sim \land [\psi]_\sim &= [\varphi \land \psi]_\sim \\
    [\varphi]_\sim \lor [\psi]_\sim &= [\varphi \lor \psi]_\sim
\end{align*}
In words, we select the representative or representatives and perform the operation with them, e.g., the `conjunction' of the classes $[p \limplies q]_\sim$ and $[q \lor \neg r]_\sim$ is:
$$
[p \limplies q]_\sim \land [q \lor \neg r]_\sim = [(p \limplies q) \land (q \lor \neg r)]_\sim
$$
By adding \emph{constants} $\bot = [\bot]_\sim$ and $\top = [\top]_\sim$, we obtain the \emph{(mathematical) structure}\footnote{A structure is a non-empty set together with relations, operations, and constants. For example, a (directed) graph, a group, a field, a vector space. Structures will play an important role in predicate logic.}
$$
\mathbf{AV}_\mathbb{P} = \langle \sfrac{\VF_\mathbb{P}}{\sim}; \neg, \land, \lor, \bot, \top \rangle
$$
which we call the \emph{algebra of propositions} of the language $\mathbb{P}$. It is an example of a so-called \emph{Boolean algebra}. This means that its operations `behave' like the operations $\overline{\phantom{x}}$, $\cap$, $\cup$ on the set of all subsets $\mathcal{P}(X)$ of some non-empty set $X$, and the constants correspond to $\emptyset$, $X$ (such a Boolean algebra is called a \emph{power set algebra}).\footnote{That is, they satisfy certain algebraic laws, such as the distributive law of $\land$ over $\lor$. Boolean algebras will be formally defined later, but let us mention another important example: the set of all $n$-bit vectors with operations $\thicksim$, $\&$, $|$ (coordinate-wise) and with constants $(0,0,\dots,0)$ and $(1,1,\dots,1)$.}

The mapping $h:\sfrac{\VF_\mathbb{P}}{\sim} \to \mathcal{P}(\M_\mathbb{P})$ is thus an injective mapping from the algebra of propositions $\mathbf{AV}_\mathbb{P}$ to the power set algebra
$$
\mathbf{\mathcal{P}(\M_\mathbb{P})} = \langle \mathcal{P}(\M_\mathbb{P}); \overline{\phantom{x}}, \cap, \cup, \emptyset, \M_\mathbb{P} \rangle
$$
and if the language is finite, it is a bijection. This mapping `preserves' the operations and constants, i.e., it holds that $h(\bot) = \emptyset$, $h(\top) = \M_\mathbb{P}$, and
\begin{align*}
    h(\neg[\varphi]_\sim) &= \overline{h([\varphi]_\sim)} = \overline{\M(\varphi)} = \M_\mathbb{P} \setminus \M(\varphi) \\
    h([\varphi]_\sim \land [\psi]_\sim) &= h([\varphi]_\sim) \cap h([\psi]_\sim) = \M(\varphi) \cap \M(\psi) \\
    h([\varphi]_\sim \lor [\psi]_\sim) &= h([\varphi]_\sim) \cup h([\psi]_\sim) = \M(\varphi) \cup \M(\psi)
\end{align*}
Such a mapping is called a \emph{homomorphism} of Boolean algebras, and if it is a bijection, it is an \emph{isomorphism}.

\begin{remark}
We can apply these relationships when searching for models: for the proposition $\varphi \limplies (\neg \psi \land \chi)$, it holds (using the fact that $\M(\varphi \limplies \varphi') = \M(\neg \varphi \lor \varphi')$):
$$
\M(\varphi \limplies (\neg \psi \land \chi)) = \overline{\M(\varphi)} \cup (\overline{\M(\psi)} \cap \M(\chi))
$$
\end{remark}

We can also relativize all of the above reasoning with respect to a given theory $T$ in the language $\mathbb{P}$ by replacing the equivalence $\sim$ with $T$-equivalence $\sim_T$ and the set of models of the language $\M_\mathbb{P}$ with the set of models of the theory $\M_\mathbb{P}(T)$. We get:
\begin{align*}
    h(\bot) &= \emptyset,\\
    h(\top) &= \M(T)\\
    h(\neg[\varphi]_{\sim_T}) &= \M(T) \setminus \M(T,\varphi)\\
    h([\varphi]_{\sim_T} \land [\psi]_{\sim_T}) &= \M(T,\varphi) \cap \M(T,\psi)\\
    h([\varphi]_{\sim_T} \lor [\psi]_{\sim_T}) &= \M(T,\varphi) \cup \M(T,\psi)
\end{align*}
The resulting \emph{algebra of propositions with respect to the theory $T$} is denoted as $\mathbf{AV}_\mathbb{P}(T)$. The algebra of propositions of the language is thus the same as the algebra of propositions with respect to the empty theory. For technical reasons, we need $\M(T)$ to be non-empty, i.e., $T$ must be consistent. Let's summarize our considerations:

\begin{corollary}\label{corollary:lt-algebra}
If $T$ is a consistent theory over a \emph{finite} language $\mathbb{P}$, then the algebra of propositions $\mathbf{AV}_\mathbb{P}(T)$ is isomorphic to the power set algebra $\mathbf{\mathcal{P}(\M_\mathbb{P}(T))}$ through the mapping $h([\varphi]_{\sim_T}) = \M(T,\varphi)$.
\end{corollary}

Thus, we know that negation, conjunction, and disjunction correspond to complement, intersection, and union of sets of models, and that if we want to find the number of propositions up to equivalence or $T$-equivalence, we just need to determine the number of corresponding sets of models. Let us summarize a few such calculations in the form of a proposition, leaving its proof as an exercise.

\begin{proposition}\label{proposition:counting-up-to-equivalence}
Let $\mathbb{P}$ be a language of size $n$ and $T$ a consistent theory in $\mathbb P$ with exactly $k$ models. Then in $\mathbb{P}$ there are, \emph{up to equivalence}:
\begin{itemize}
    \item $2^{2^n}$ propositions (or theories),
    \item $2^{2^n - k}$ propositions true (or false) in $T$,
    \item $2^{2^n} - 2 \cdot 2^{2^n - k}$ propositions independent in $T$,
    \item $2^k$ simple extensions of the theory $T$ (of which 1 is inconsistent),
    \item $k$ complete simple extensions of $T$.
\end{itemize}
Furthermore, \emph{up to $T$-equivalence}, there are:
\begin{itemize}
    \item $2^k$ propositions,
    \item $1$ proposition true in $T$, $1$ false in $T$,
    \item $2^k - 2$ propositions independent in $T$.
\end{itemize}
\end{proposition}

\begin{exercise}
    Choose a suitable theory $T$ and use it as an example to demonstrate that Proposition \ref{proposition:counting-up-to-equivalence} holds.
\end{exercise}

\begin{exercise}
    Prove Proposition \ref{proposition:counting-up-to-equivalence} in detail. (Draw a Venn diagram.)
\end{exercise}

\begin{exercise}
    Prove in detail that the mapping $h$ from Corollary \ref{corollary:lt-algebra} is well-defined, injective, and if the language is finite, also surjective.
\end{exercise}
